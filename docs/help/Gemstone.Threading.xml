<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>Gemstone.Threading</name>
  </assembly>
  <members>
    <member name="T:Gemstone.Threading.AsyncLock">
      <summary>
            Represents a lock that can be awaited to obtain exclusive
            access to resources within a critical region of code.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.AsyncLock.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Gemstone.Threading.AsyncLock</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Gemstone.Threading.AsyncLock.EnterAsync">
      <summary>
            Obtains exclusive access to the lock.
            </summary>
      <returns>
            A task that must be awaited to obtain the token that will
            release the lock on <see cref="M:System.IDisposable.Dispose" />.
            </returns>
    </member>
    <member name="M:Gemstone.Threading.AsyncLock.TryEnterAsync">
      <summary>
            Attempts to obtain exclusive access to the lock.
            </summary>
      <returns>
            A task that, if cancelled, indicates the lock was not taken,
            and must be awaited to obtain the token that will release the
            lock on <see cref="M:System.IDisposable.Dispose" />.
            </returns>
      <exception cref="T:System.Threading.Tasks.TaskCanceledException">The lock could not be taken.</exception>
    </member>
    <member name="M:Gemstone.Threading.AsyncLock.TryEnterAsync(System.Int32)">
      <summary>
            Attempts to obtain exclusive access to the lock.
            </summary>
      <param name="milliseconds">The number of milliseconds to wait before failing to take the lock.</param>
      <returns>
            A task that, if cancelled, indicates the lock was not taken,
            and must be awaited to obtain the token that will release the
            lock on <see cref="M:System.IDisposable.Dispose" />.
            </returns>
      <exception cref="T:System.Threading.Tasks.TaskCanceledException">The timeout expires before the lock could be taken.</exception>
    </member>
    <member name="M:Gemstone.Threading.AsyncLock.TryEnterAsync(System.TimeSpan)">
      <summary>
            Attempts to obtain exclusive access to the lock.
            </summary>
      <param name="timeout">The amount of time to wait before failing to take the lock.</param>
      <returns>
            A task that, if cancelled, indicates the lock was not taken,
            and must be awaited to obtain the token that will release the
            lock on <see cref="M:System.IDisposable.Dispose" />.
            </returns>
      <remarks>
        <para>
            The following illustrates an example of using try-catch to detect a failure to take the lock.
            </para>
        <code>
            AsyncLock asyncLock = new AsyncLock();
            
            try
            {
                using IDisposable token = await asyncLock.TryEnterAsync();
                // Critical region
            }
            catch (TaskCanceledException)
            {
                // Lock failed
            }
            </code>
        <para>
            The following illustrates an example of using <see cref="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
            to detect a failure to take the lock.
            </para>
        <code>
            AsyncLock asyncLock = new AsyncLock();
            
            await asyncLock.TryEnterAsync().ContinueWith(async tokenTask =&gt;
            {
                if (tokenTask.IsCanceled)
                {
                    // Lock failed
                    return;
                }
            
                using IDisposable token = await tokenTask;
                // Critical region
            }).Unwrap();
            </code>
      </remarks>
      <exception cref="T:System.Threading.Tasks.TaskCanceledException">The <paramref name="timeout" /> expires before the lock could be taken.</exception>
    </member>
    <member name="T:Gemstone.Threading.AsyncReaderWriterLock">
      <summary>
            Represents an asynchronous implementation of a reader/writer lock.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Gemstone.Threading.AsyncReaderWriterLock</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.EnterReadAsync">
      <summary>
            Enters the lock with concurrent access where all readers
            can execute concurrently with respect to each other.
            </summary>
      <returns>The token used to control the duration of entry.</returns>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.EnterWriteAsync">
      <summary>
            Enters the lock with exclusive access where no other
            readers or writers can execute concurrently with the writer.
            </summary>
      <returns>The token used to control the duration of entry.</returns>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.TryEnterReadLockAsync(System.Int32)">
      <summary>
            Attempts to enter the lock with concurrent access where all
            readers can execute concurrently with respect to each other.
            </summary>
      <param name="milliseconds">The number of milliseconds to wait before timing out.</param>
      <returns>The token used to control the duration of entry.</returns>
      <exception cref="T:System.TimeoutException">The lock could not be entered before the timeout expired.</exception>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.TryEnterReadLockAsync(System.TimeSpan)">
      <summary>
            Attempts to enter the lock with concurrent access where all
            readers can execute concurrently with respect to each other.
            </summary>
      <param name="timeout">The amount of time to wait before timing out.</param>
      <returns>The token used to control the duration of entry.</returns>
      <exception cref="T:System.TimeoutException">The lock could not be entered before the <paramref name="timeout" /> expired.</exception>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.TryEnterWriteLockAsync(System.Int32)">
      <summary>
            Attempts to enter the lock with exclusive access where no other
            readers or writers can execute concurrently with the writer.
            </summary>
      <param name="milliseconds">The number of milliseconds to wait before timing out.</param>
      <returns>The token used to control the duration of entry.</returns>
      <exception cref="T:System.TimeoutException">The lock could not be entered before the timeout expired.</exception>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.TryEnterWriteLockAsync(System.TimeSpan)">
      <summary>
            Attempts to enter the lock with exclusive access where no other
            readers or writers can execute concurrently with the writer.
            </summary>
      <param name="timeout">The amount of time to wait before timing out.</param>
      <returns>The token used to control the duration of entry.</returns>
      <exception cref="T:System.TimeoutException">The lock could not be entered before the <paramref name="timeout" /> expired.</exception>
    </member>
    <member name="T:Gemstone.Threading.ConcurrencyLimiter">
      <summary>
            Task scheduler that limits the number of tasks that can execute in parallel at any given time.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.ConcurrencyLimiter" /> class
            with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" /> and a maximum concurrency
            level equal to the number of processors on the current machine.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.ConcurrencyLimiter" /> class with a
            maximum concurrency level equal to the number of processors on the current machine.
            </summary>
      <param name="synchronizedOperationFactory">Factory function for creating the synchronized operations to be used for processing tasks.</param>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory,System.Int32)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.ConcurrencyLimiter" /> class.
            </summary>
      <param name="synchronizedOperationFactory">Factory function for creating the synchronized operations to be used for processing tasks.</param>
      <param name="maximumConcurrencyLevel">The initial value for <see cref="P:Gemstone.Threading.ConcurrencyLimiter.MaximumConcurrencyLevel" />.</param>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(System.Int32)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.ConcurrencyLimiter" /> class
            with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />.
            </summary>
      <param name="maximumConcurrencyLevel">The initial value for <see cref="P:Gemstone.Threading.ConcurrencyLimiter.MaximumConcurrencyLevel" />.</param>
    </member>
    <member name="P:Gemstone.Threading.ConcurrencyLimiter.CurrentConcurrencyLevel">
      <summary>
            Gets the number of threads that are currently executing tasks concurrently.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.GetScheduledTasks">
      <summary>
            For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task" />
            instances currently queued to the scheduler waiting to be executed.
            </summary>
      <returns>An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</returns>
    </member>
    <member name="P:Gemstone.Threading.ConcurrencyLimiter.MaximumConcurrencyLevel">
      <summary>
            Gets the maximum number of threads that can be executing tasks concurrently.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.QueueTask(System.Threading.Tasks.Task)">
      <summary>
            Queues a <see cref="T:System.Threading.Tasks.Task" /> to the scheduler.
            </summary>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task" /> to be queued.</param>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.SetMaximumConcurrencyLevel(System.Int32)">
      <summary>
            Sets the maximum number of threads that can be executing tasks concurrently.
            </summary>
      <param name="maximumConcurrencyLevel">The maximum concurrency level.</param>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
      <summary>
            Determines whether the provided <see cref="T:System.Threading.Tasks.Task" /> can be executed synchronously
            in this call, and if it can, executes it.
            </summary>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task" /> to be executed.</param>
      <param name="taskWasPreviouslyQueued">
            A <see cref="T:System.Boolean" /> denoting whether or not task has previously been queued.
            If this parameter is True, then the task may have been previously queued (scheduled);
            if False, then the task is known not to have been queued,
            and this call is being made in order to execute the task inline without queuing it.
            </param>
      <returns>A <see cref="T:System.Boolean" /> value indicating whether the task was executed inline.</returns>
    </member>
    <member name="T:Gemstone.Threading.RateLimiter">
      <summary>
            A rate limiting system based on tokes.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.RateLimiter.#ctor(System.Double,System.Int32)">
      <summary>
            Creates a <see cref="T:Gemstone.Threading.RateLimiter" /></summary>
      <param name="tokensPerSecond">The number of tokens per second that can be generated. Must be greater than zero and less than 1 billion</param>
      <param name="maxTokensQueue">The maximum number of tokens in the queue. Must be at least 1</param>
    </member>
    <member name="M:Gemstone.Threading.RateLimiter.TryTakeToken">
      <summary>
            Attempts to take a token from the rate limiter.
            </summary>
      <returns>true if token was successfully taken, False if all tokens were consumed.</returns>
    </member>
    <member name="M:Gemstone.Threading.RateLimiter.UpdateLimits(System.Double,System.Int32)">
      <summary>
            Updates the limits associated with this rate limiter. Note, after this update, the tokens will be completely resupplied.
            </summary>
      <param name="tokensPerSecond">The number of tokens per second that can be generated. Must be greater than zero and less than 1 billion</param>
      <param name="maxTokensQueue">The maximum number of tokens in the queue. Must be at least 1</param>
    </member>
    <member name="T:Gemstone.Threading.ReaderWriterSpinLock">
      <summary>
            Represents a fast, lightweight reader/writer lock that uses spinning to perform locking. No recursive acquires or
            upgradable locks are allowed (i.e., all entered locks must be exited before entering another lock).
            </summary>
      <remarks>
            This reader/writer lock uses <see cref="T:System.Threading.SpinWait" /> to spin the CPU instead of engaging event based locking. As a result it
            should only be used in cases where lock times are expected to be very small, reads are very frequent and writes are rare.
            If hold times for write locks can be lengthy, it will be better to use <see cref="T:System.Threading.ReaderWriterLockSlim" /> instead to avoid
            unnecessary CPU utilization due to spinning incurred by waiting reads.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.ReaderWriterSpinLock.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Gemstone.Threading.ReaderWriterSpinLock</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Gemstone.Threading.ReaderWriterSpinLock.EnterReadLock">
      <summary>
            Enters the lock in read mode.
            </summary>
      <remarks>
            Upon successful acquisition of a read lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.ExitReadLock" />.
            One <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.ExitReadLock" /> should be called for each <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.EnterReadLock" />.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.ReaderWriterSpinLock.EnterWriteLock">
      <summary>
            Enters the lock in write mode.
            </summary>
      <remarks>
            Upon successful acquisition of a write lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.ExitWriteLock" />.
            One <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.ExitWriteLock" /> should be called for each <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.EnterWriteLock" />.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.ReaderWriterSpinLock.ExitReadLock">
      <summary>
            Exits read mode.
            </summary>
      <exception cref="T:System.InvalidOperationException">Cannot exit read lock when there are no readers.</exception>
    </member>
    <member name="M:Gemstone.Threading.ReaderWriterSpinLock.ExitWriteLock">
      <summary>
            Exits write mode.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.ScheduledTask">
      <summary>
            Represents a way to schedule a task to be executed on a separate thread immediately or after a given time delay.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ScheduledTask.#ctor(Gemstone.Threading.ThreadingMode,System.Threading.ThreadPriority,System.Boolean)">
      <summary>
            Creates a <see cref="T:Gemstone.Threading.ScheduledTask" />.
            </summary>
      <param name="threadMode">The manner in which the scheduled task executes.</param>
      <param name="priority">The thread priority to assign if a dedicated thread is used. This is ignored if using the thread-pool.</param>
      <param name="disposeOnShutdown">Adds a handler to <see cref="T:Gemstone.Threading.ShutdownHandler" /> that requires this class to be disposed
            when the application is shutdown. Note: If this object has been garbage collected, this will have no effect.</param>
    </member>
    <member name="M:Gemstone.Threading.ScheduledTask.Dispose">
      <summary>
            Starts the disposing process of exiting the worker thread. 
            </summary>
      <remarks>
        <para>Callback will be invoked one more time. Duplicate calls are ignored.</para>
        <para>
            Unless called from the worker thread, this method will block until the dispose
            has successfully completed.
            </para>
      </remarks>
    </member>
    <member name="E:Gemstone.Threading.ScheduledTask.Disposing">
      <summary>
            Occurs right before this task is disposed.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ScheduledTask.Finalize">
      <summary>
            Cleans up the <see cref="T:Gemstone.Threading.ThreadContainerBase" /> thread since that class likely will never be garbage collected.
            </summary>
    </member>
    <member name="E:Gemstone.Threading.ScheduledTask.Running">
      <summary>
            Occurs every time the task should run.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ScheduledTask.Start">
      <summary>
            Starts the task immediately, or if one was scheduled, starts the scheduled task immediately
            </summary>
      <remarks>
        <para>
            If this is called after a <see cref="M:Gemstone.Threading.ScheduledTask.Start(System.Int32)" /> the timer will be canceled
            and the process will still start immediately. 
            </para>
        <para>
            This method is safe to call from any thread, including the worker thread.
            If disposed, this method will no nothing.
            </para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.ScheduledTask.Start(System.Int32)">
      <summary>
            Starts a timer to run the task after a provided interval. 
            </summary>
      <param name="delay">the delay in milliseconds before the task should run</param>
      <remarks>
        <para>
            If a timer is currently pending, this function will do nothing. Do not use this
            function to reset or restart an existing timer.
            </para>
        <para>
            If called while working, a subsequent timer will be scheduled, but delay will not
            start until after the worker has completed.
            </para>
        <para>
            This method is safe to call from any thread, including the worker thread.
            If disposed, this method will no nothing.
            </para>
      </remarks>
    </member>
    <member name="E:Gemstone.Threading.ScheduledTask.UnhandledException">
      <summary>
            Occurs when <see cref="E:Gemstone.Threading.ScheduledTask.Running" /> or <see cref="E:Gemstone.Threading.ScheduledTask.Disposing" /> event throws an exception.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.ScheduledTaskRunningReason">
      <summary>
            Metadata about why this worker was called.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.ScheduledTaskRunningReason.Running">
      <summary>
            A normal run was scheduled.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.ScheduledTaskRunningReason.Disposing">
      <summary>
            Dispose was called and execution will terminate after this function call.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.SharedTimer">
      <summary>
            Represents a timer class that will group registered timer event callbacks that operate on the same
            interval in order to optimize thread pool queuing.
            </summary>
      <remarks>
        <para>
            Externally the <see cref="T:Gemstone.Threading.SharedTimer" /> operations similar to the <see cref="T:System.Timers.Timer" />.
            Internally the timer pools callbacks with the same <see cref="P:Gemstone.Threading.SharedTimer.Interval" /> into a single timer where
            each callback is executed on the same thread, per instance of the <see cref="T:Gemstone.Threading.SharedTimerScheduler" />. 
            </para>
        <para>
            Any long running callbacks that have a risk of long delays should not use <see cref="T:Gemstone.Threading.SharedTimer" />
            as this will effect the reliability of all of the other <see cref="T:Gemstone.Threading.SharedTimer" /> instances for a
            given <see cref="T:Gemstone.Threading.SharedTimerScheduler" />.
            </para>
      </remarks>
    </member>
    <member name="P:Gemstone.Threading.SharedTimer.AutoReset">
      <summary>
            Gets or sets flag that indicates whether the <see cref="T:Gemstone.Threading.SharedTimer" /> should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event only
            once <c>false</c> or repeatedly <c>true</c>.
            </summary>
      <returns>
        <c>true</c> the <see cref="T:Gemstone.Threading.SharedTimer" /> should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event each time the interval elapses; otherwise,
            <c>false</c> if it should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event only once, after the first time the interval elapses.
            The default is <c>true</c>.
            </returns>
    </member>
    <member name="M:Gemstone.Threading.SharedTimer.Close">
      <summary>
            Stops the timer.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SharedTimer.Dispose">
      <summary>
            Stops the timer and prevents reuse of the class.
            </summary>
    </member>
    <member name="E:Gemstone.Threading.SharedTimer.Elapsed">
      <summary>
            Occurs when the timer interval elapses.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SharedTimer.Enabled">
      <summary>
            Gets or sets flag that indicates whether the <see cref="T:Gemstone.Threading.SharedTimer" /> should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event.
            </summary>
      <returns>
        <c>true</c> if the <see cref="T:Gemstone.Threading.SharedTimer" /> should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event; otherwise, <c>false</c>.
            The default is <c>false</c>.
            </returns>
    </member>
    <member name="P:Gemstone.Threading.SharedTimer.Interval">
      <summary>
            Gets or sets the interval at which to raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event.
            </summary>
      <returns>The time, in milliseconds, between <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> events.</returns>
      <remarks>
            The value must be greater than zero, and less than or equal to <see cref="F:System.Int32.MaxValue" />.
            The default is 100 milliseconds.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SharedTimer.Start">
      <summary>
            Starts raising the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event by setting <see cref="P:Gemstone.Threading.SharedTimer.Enabled" /> to <c>true</c>.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SharedTimer.Status">
      <summary>
            Gets the current status details about object providing status information.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SharedTimer.Stop">
      <summary>
            Stops raising the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event by setting <see cref="P:Gemstone.Threading.SharedTimer.Enabled" /> to <c>false</c>.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.SharedTimerScheduler">
      <summary>
            Represents a timer manager which is the scheduler of <see cref="T:Gemstone.Threading.SharedTimer" />.
            </summary>
      <remarks>
            A <see cref="T:Gemstone.Threading.SharedTimer" /> with the same scheduler will use the same ThreadPool thread to process
            all of the <see cref="T:Gemstone.Threading.SharedTimer" /> instances in series when they have a common interval. Call
            order, based on registration sequence, will be preserved.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SharedTimerScheduler.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SharedTimerScheduler" /> class.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SharedTimerScheduler.CreateTimer(System.Int32)">
      <summary>
            Creates a <see cref="T:Gemstone.Threading.SharedTimer" /> using the current <see cref="T:Gemstone.Threading.SharedTimerScheduler" />.
            </summary>
      <param name="interval">The interval of the timer, default is 100.</param>
      <returns>A shared timer instance that fires at the given interval.</returns>
    </member>
    <member name="M:Gemstone.Threading.SharedTimerScheduler.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SharedTimerScheduler.IsDisposed">
      <summary>
            Gets flag that determines if this <see cref="T:Gemstone.Threading.SharedTimerScheduler" /> instance has been disposed.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.ShutdownHandler">
      <summary>
            This class will monitor the state to the application and raise events when it detects that the application is about to shut down.
            </summary>
      <remarks>
            This class is duplicated here from the Gemstone.Diagnostics project as an internal class to avoid a circular dependency.
            </remarks>
    </member>
    <member name="P:Gemstone.Threading.ShutdownHandler.HasShutdown">
      <summary>
            Gets if this process has already shut down.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ShutdownHandler.Initialize">
      <summary>
            Initializes the shutdown handler. This is recommended to put in main loop of the program, but it is not critical.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ShutdownHandler.InitiateSafeShutdown">
      <summary>
            Requests that certain components initiate a safe shutdown.
            </summary>
      <remarks>
            This method should only be called when the main thread exits. Calling this outside
            of the application exiting could result in unpredictable behavior.
            </remarks>
    </member>
    <member name="P:Gemstone.Threading.ShutdownHandler.IsShuttingDown">
      <summary>
            Gets if this process is shutting down.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ShutdownHandler.TryRegisterCallback(System.Action,Gemstone.Threading.ShutdownHandlerOrder)">
      <summary>
            Attempts Registers a callback that will be called
            when the application is shutdown.
            </summary>
      <param name="callback">the callback when the shutdown occurs</param>
      <param name="shutdownOrder">the order that the callback will occur.</param>
      <returns>
        <markup>
          <include item="SMCMissingTag">
            <parameter>returns</parameter>
            <parameter>M:Gemstone.Threading.ShutdownHandler.TryRegisterCallback(System.Action,Gemstone.Threading.ShutdownHandlerOrder)</parameter>
          </include>
        </markup>
      </returns>
    </member>
    <member name="T:Gemstone.Threading.ShutdownHandlerOrder">
      <summary>
            The order in which the specified callback should occur when shutting down.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.ShutdownHandlerOrder.First">
      <summary>
            This queue is processed first. Unless there is a compelling reason to execute first, select the Default one. 
            </summary>
    </member>
    <member name="F:Gemstone.Threading.ShutdownHandlerOrder.Default">
      <summary>
            This shutdown order occurs after First, but before Last. 
            </summary>
    </member>
    <member name="F:Gemstone.Threading.ShutdownHandlerOrder.Last">
      <summary>
            This queue is processed last. Items such as flushing application logs should go here.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.TaskCompletionSourceFactory">
      <summary>
            Provides factory functions for creating new
            <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> objects.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.TaskCompletionSourceFactory.CreateNew``1">
      <summary>
            Creates a new instance of the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> class.
            </summary>
      <typeparam name="T">The type of the result value associated with the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</typeparam>
      <returns>A new object of type <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</returns>
    </member>
    <member name="M:Gemstone.Threading.TaskCompletionSourceFactory.CreateNew``1(System.Object)">
      <summary>
            Creates a new instance of the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> class.
            </summary>
      <param name="state">The state to use as the underlying <see cref="T:System.Threading.Tasks.Task" />'s <see cref="P:System.Threading.Tasks.Task.AsyncState" />.</param>
      <typeparam name="T">The type of the result value associated with the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</typeparam>
      <returns>A new object of type <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</returns>
    </member>
    <member name="F:Gemstone.Threading.TaskCompletionSourceFactory.DefaultTaskCreationOptions">
      <summary>
            The default <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used by this factory
            for creating new <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> objects.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.ThreadingMode">
      <summary>
            Specifies the threading mode to use for the <see cref="T:Gemstone.Threading.ScheduledTask" /></summary>
    </member>
    <member name="F:Gemstone.Threading.ThreadingMode.DedicatedForeground">
      <summary>
            A dedicated thread that is a foreground thread.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.ThreadingMode.DedicatedBackground">
      <summary>
            A dedicated thread that is a background thread.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.ThreadingMode.ThreadPool">
      <summary>
            A background thread from the thread pool.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.WeakAction">
      <summary>
            Provides a weak referenced <see cref="T:System.Action" /> delegate.
            </summary>
      <remarks>
            This class will store the information necessary so the callback
            object will have a weak reference to it. This information is compiled
            an can be quickly executed without the overhead of using reflection.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.WeakAction.#ctor(System.Action)">
      <summary>
            Creates a WeakAction.
            </summary>
      <param name="callback">The callback.</param>
    </member>
    <member name="M:Gemstone.Threading.WeakAction.Clear">
      <summary>
            Clears <see cref="T:System.Action" /> callback target.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.WeakAction.TryInvoke">
      <summary>
            Attempts to invoke the delegate to a weak reference object.
            </summary>
      <returns>
        <c>true</c> if successful; otherwise, <c>false</c>.</returns>
    </member>
    <member name="T:Gemstone.Threading.WeakAction`1">
      <summary>
            Provides a weak referenced <see cref="T:System.Action" /> delegate.
            </summary>
      <typeparam name="T">
        <markup>
          <include item="SMCMissingParamTag">
            <parameter>typeparam</parameter>
            <parameter>T</parameter>
            <parameter>T:Gemstone.Threading.WeakAction`1</parameter>
          </include>
        </markup>
      </typeparam>
      <remarks>
            This class will store the information necessary so the callback
            object will have a weak reference to it. This information is compiled
            an can be quickly executed without the overhead of using reflection.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.WeakAction`1.#ctor(System.Action{`0})">
      <summary>
            Creates a WeakAction.
            </summary>
      <param name="callback">The callback.</param>
    </member>
    <member name="M:Gemstone.Threading.WeakAction`1.Clear">
      <summary>
            Clears <see cref="T:System.Action" /> callback target.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.WeakAction`1.TryInvoke(`0)">
      <summary>
            Attempts to invoke the delegate to a weak reference object.
            </summary>
      <param name="param1">
        <markup>
          <include item="SMCMissingParamTag">
            <parameter>param</parameter>
            <parameter>param1</parameter>
            <parameter>M:Gemstone.Threading.WeakAction`1.TryInvoke(`0)</parameter>
          </include>
        </markup>
      </param>
      <returns>
        <c>true</c> if successful; otherwise, <c>false</c>.</returns>
    </member>
    <member name="T:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1">
      <summary>
            Combines <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1" /> and <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueue`1" /> to provide
            a low-contention, double-buffered queue suitable for multiple-producer, single-consumer
            scenarios.
            </summary>
      <typeparam name="T">Type of items being queued.</typeparam>
    </member>
    <member name="M:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1" /> class.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.Count">
      <summary>
            Gets the number of items in the queue.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.Enqueue(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Enqueues a collection of items into the async double-buffered queue.
            </summary>
      <param name="items">The items to be queued.</param>
    </member>
    <member name="E:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.ProcessException">
      <summary>
            Event that is raised if an exception is encountered while attempting to processing an item in the <see cref="T:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1" />.
            </summary>
      <remarks>
            Processing will not stop for any exceptions thrown by user processing function, but exceptions will be exposed through this event.
            </remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.ProcessItemsFunction">
      <summary>
            Gets or sets item processing function.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.Collections.AsyncQueue`1">
      <summary>
            Creates a fast, light-weight asynchronous processing queue with very low contention.
            </summary>
      <typeparam name="T">Type of items to process.</typeparam>
    </member>
    <member name="M:Gemstone.Threading.Collections.AsyncQueue`1.#ctor">
      <summary>
            Creates a new <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.AsyncQueue`1.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationType)">
      <summary>
            Creates a new <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1" />.
            </summary>
      <param name="synchronizedOperationType">The type of synchronized operation to use to process items in the queue.</param>
    </member>
    <member name="P:Gemstone.Threading.Collections.AsyncQueue`1.Count">
      <summary>
            Gets the total number of items currently in the queue.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.AsyncQueue`1.Enabled">
      <summary>
            Gets or sets flag that enables or disables processing.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.AsyncQueue`1.Enqueue(`0)">
      <summary>
            Enqueues an item for processing.
            </summary>
      <param name="item">Item to be queued for processing.</param>
    </member>
    <member name="E:Gemstone.Threading.Collections.AsyncQueue`1.ProcessException">
      <summary>
            Event that is raised if an exception is encountered while attempting to processing an item in the <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1" />.
            </summary>
      <remarks>
            Processing will not stop for any exceptions thrown by user processing function, but exceptions will be exposed through this event.
            </remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.AsyncQueue`1.ProcessItemFunction">
      <summary>
            Gets or sets item processing function.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.Collections.DoubleBufferedQueue`1">
      <summary>
            A thread-safe double-buffered queue that allows for low-contention
            item processing in single-producer, single-consumer scenarios.
            </summary>
      <typeparam name="T">Type of items being queued.</typeparam>
      <remarks>
            It is not safe to use this class with multiple consumer threads.
            The <see cref="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Dequeue" /> method must be called by one thread at
            a time, and the consumer must not access a list returned by Dequeue
            after its next call to Dequeue.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueue`1" /> class.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Clear">
      <summary>
            Empties the producer's buffer so that the
            items can no longer be consumed by the consumer.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Count">
      <summary>
            Gets the current number of items in the queue.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Dequeue">
      <summary>
            Dequeues a collection of items from the queue.
            </summary>
      <returns>
            A collection of items that have previously been enqueued,
            or no items if none have been enqueued since last dequeue.
            </returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Enqueue(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Enqueues a collection of items into the double-buffered queue.
            </summary>
      <param name="items">The collection of items to be enqueued.</param>
    </member>
    <member name="E:Gemstone.Threading.Collections.DoubleBufferedQueue`1.ProcessException">
      <summary>
            Event that is raised if an exception is encountered while attempting to processing an item in the <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1" />.
            </summary>
      <remarks>
            Processing will not stop for any exceptions thrown by user processing function, but exceptions will be exposed through this event.
            </remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.DoubleBufferedQueue`1.ProcessItemsFunction">
      <summary>
            Gets or sets item processing function.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.TryClear">
      <summary>
            Attempts to enqueue a collection of items into the double-buffered queue.
            </summary>
      <returns>
            True if the items were successfully enqueued; false otherwise.
            </returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.TryDequeue(System.Collections.Generic.IList{`0}@)">
      <summary>
            Attempts to dequeue a collection of items from the queue and
            returns the number of items left in the queue after dequeuing.
            </summary>
      <param name="items">The items that were dequeued.</param>
      <returns>
            The number of items left in the queue after
            dequeuing as many items as possible.
            </returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.TryEnqueue(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Attempts to enqueue a collection of items into the double-buffered queue.
            </summary>
      <param name="items">The collection of items to be enqueued.</param>
      <returns>
            True if the items were successfully enqueued; false otherwise.
            </returns>
    </member>
    <member name="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1">
      <summary>
            Manages queues to reduce contention for a multithreaded, multiple-producer, single-consumer scenario.
            </summary>
      <typeparam name="T">The types of items to be queued.</typeparam>
      <remarks>
            For best results, each thread that is producing items to the consumer should call
            <see cref="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.GetProducer" /> to receive a producer object that will not contend with
            any other producer. The consumer should either provide a handler to process the queued
            items or poll the manager by calling <see cref="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.Dequeue" /> (not both!). It is not
            safe to use this class with multiple consumer threads.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" /> class.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor(System.Action)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" /> class.
            </summary>
      <param name="itemHandler">The method to handle processing of queued items.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor(System.Action,System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" /> class.
            </summary>
      <param name="itemHandler">The method to handle processing of queued items.</param>
      <param name="exceptionHandler">The method to handle exceptions that occur when processing items.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor(System.Action{System.Collections.Generic.IList{`0}})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" /> class.
            </summary>
      <param name="itemHandler">The method to handle processing of queued items.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor(System.Action{System.Collections.Generic.IList{`0}},System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" /> class.
            </summary>
      <param name="itemHandler">The method to handle processing of queued items.</param>
      <param name="exceptionHandler">The method to handle exceptions that occur when processing items.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.Dequeue">
      <summary>
            Dequeues a list of items produced by the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1" />s.
            </summary>
      <returns>A list of items to be consumed.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.GetProducer">
      <summary>
            Creates a producer used to produce items to the consumer of this <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" />.
            </summary>
      <returns>A <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1" /> used to produce items to the consumer.</returns>
    </member>
    <member name="P:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.ItemsLeft">
      <summary>
            Gets a flag that indicates whether there are any items left to
            be consumed after the last call to <see cref="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.Dequeue" />.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1">
      <summary>
            A producer for a <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueue`1" /> which can
            only be used to provide items to the queue for consumption.
            </summary>
      <typeparam name="T">The type of the items produced to the queue.</typeparam>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1.Dispose">
      <summary>
            Releases all the resources used by the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1" /> object.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1.Dispose(System.Boolean)">
      <summary>
            Releases the unmanaged resources used by the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1" /> object and optionally releases the managed resources.
            </summary>
      <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1.Finalize">
      <summary>
            Releases the unmanaged resources before the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1" /> object is reclaimed by <see cref="T:System.GC" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1.Produce(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Produces a collection of items to be processed by the consumer.
            </summary>
      <param name="items">The collection of items to be enqueued.</param>
    </member>
    <member name="T:Gemstone.Threading.Collections.PriorityQueue`1">
      <summary>
            Represents a thread-safe prioritized first in-first out (FIFO) collection.
            </summary>
      <typeparam name="T">The type of elements contained in the queue.</typeparam>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> class.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor(Gemstone.Threading.Collections.PriorityQueue{`0})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> class.
            </summary>
      <param name="priorityQueue">Another priority queue of items to be enqueued in this queue at the same priority.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="priorityQueue" /> queue length is less than or equal to 0.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="priorityQueue" /> is <c>null</c>.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor(System.Int32)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> class.
            </summary>
      <param name="priorityLevels">The number of priority levels to preallocate in the queue.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="priorityLevels" /> is less than or equal to 0.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> elements to an existing
            one-dimensional <see cref="T:System.Array" />, starting at the specified array index.
            </summary>
      <param name="array">
            The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied
            from the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" />. The <see cref="T:System.Array" /> must
            have zero-based indexing.
            </param>
      <param name="index">The zero-based index in array at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">index is less than zero.</exception>
      <exception cref="T:System.ArgumentException">
            index is equal to or greater than the length of the array -or- The number of
            elements in the source <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> is greater
            than the available space from index to the end of the destination array.
            </exception>
    </member>
    <member name="P:Gemstone.Threading.Collections.PriorityQueue`1.Count">
      <summary>
            Gets the number of items in the queue.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.Enqueue(`0,System.Int32)">
      <summary>
            Enqueues an item into the priority queue.
            </summary>
      <param name="item">The item to be enqueued.</param>
      <param name="priority">The priority at which the item should be queued. Larger numbers have higher priority!</param>
      <remarks>
            This priority queue is implemented using an array of <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.
            The array index indicates the priority of tasks in each queue. For best performance,
            ensure that your code defines all priority levels consecutively, starting from 0.
            </remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="priority" /> is negative</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" />.
            </summary>
      <returns>An enumerator for the contents of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" />.</returns>
    </member>
    <member name="P:Gemstone.Threading.Collections.PriorityQueue`1.IsEmpty">
      <summary>
            Indicates whether the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> is empty.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.ToArray">
      <summary>
            Copies the elements stored in the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> to a new array.
            </summary>
      <returns>A new array containing a snapshot of elements copied from the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" />.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.TryDequeue(System.Int32,`0@)">
      <summary>
            Dequeues an item from the priority queue.
            </summary>
      <param name="priority">The priority at which the item should be dequeued.</param>
      <param name="result">The item that was dequeued, or the default value if no item was dequeued.</param>
      <returns>True if an item was dequeued; false if the queue is empty.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.TryDequeue(`0@)">
      <summary>
            Dequeues an item from the priority queue.
            </summary>
      <param name="result">The item that was dequeued, or the default value if no item was dequeued.</param>
      <returns>True if an item was dequeued; false if the queue is empty.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.TryPeek(System.Int32,`0@)">
      <summary>
            Tries to return an object from the beginning of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> without removing it.
            </summary>
      <param name="priority">The priority at which to peek into the queue.</param>
      <param name="result">
            When this method returns, result contains an object from the beginning of the
            <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> or an unspecified value if the operation failed.
            </param>
      <returns>true if an object was returned successfully; otherwise, false.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.TryPeek(`0@)">
      <summary>
            Tries to return an object from the beginning of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> without removing it.
            </summary>
      <param name="result">
            When this method returns, result contains an object from the beginning of the
            <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> or an unspecified value if the operation failed.
            </param>
      <returns>true if an object was returned successfully; otherwise, false.</returns>
    </member>
    <member name="T:Gemstone.Threading.Collections.ProcessQueue`1">
      <summary>
            Represents a thread-safe (via locking) list of items, based on <see cref="T:System.Collections.Generic.List`1" />, that get processed on independent threads with a consumer provided function.
            </summary>
      <typeparam name="T">Type of object to process</typeparam>
      <remarks>
        <para>This class acts as a strongly-typed collection of objects to be processed.</para>
        <para>Note that the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> will not start processing until the Start method is called.</para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.#ctor(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Creates a <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> based on the generic List(Of T) class.
            </summary>
      <param name="processItemFunction">Delegate that defines a method to process one item at a time.</param>
      <param name="canProcessItemFunction">Delegate that determines if an item can currently be processed.</param>
      <param name="processInterval">a <see cref="T:System.Double" /> value which represents the process interval in milliseconds.</param>
      <param name="maximumThreads">The maximum number of threads for the queue to use.</param>
      <param name="processTimeout">The number of seconds before a process should timeout.</param>
      <param name="requeueOnTimeout">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue an item on timeout.</param>
      <param name="requeueOnException">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue after an exception.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.#ctor(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Collections.Generic.IList{`0},System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Allows derived classes to define their own instance, if desired.
            </summary>
      <param name="processItemFunction">Delegate that defines a method to process one item at a time.</param>
      <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
      <param name="canProcessItemFunction">Delegate that determines if an item can currently be processed.</param>
      <param name="processList">A storage list for items to be processed.</param>
      <param name="processInterval">a <see cref="T:System.Double" /> value which represents the process interval in milliseconds.</param>
      <param name="maximumThreads">The maximum number of threads for the queue to use.</param>
      <param name="processTimeout">The number of seconds before a process should timeout.</param>
      <param name="requeueOnTimeout">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue an item on timeout.</param>
      <param name="requeueOnException">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue after an exception.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.#ctor(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Creates a <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> based on the generic List(Of T) class.
            </summary>
      <param name="processItemFunction">Delegate that defines a method to process one item at a time.</param>
      <param name="processInterval">a <see cref="T:System.Double" /> value which represents the process interval in milliseconds.</param>
      <param name="maximumThreads">The maximum number of threads for the queue to use.</param>
      <param name="processTimeout">The number of seconds before a process should timeout.</param>
      <param name="requeueOnTimeout">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue an item on timeout.</param>
      <param name="requeueOnException">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue after an exception.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.#ctor(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Creates a bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> based on the generic List(Of T) class.
            </summary>
      <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
      <param name="canProcessItemFunction">Delegate that determines if an item can currently be processed.</param>
      <param name="processInterval">a <see cref="T:System.Double" /> value which represents the process interval in milliseconds.</param>
      <param name="maximumThreads">The maximum number of threads for the queue to use.</param>
      <param name="processTimeout">The number of seconds before a process should timeout.</param>
      <param name="requeueOnTimeout">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue an item on timeout.</param>
      <param name="requeueOnException">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue after an exception.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.#ctor(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Creates a bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> based on the generic List(Of T) class.
            </summary>
      <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
      <param name="processInterval">a <see cref="T:System.Double" /> value which represents the process interval in milliseconds.</param>
      <param name="maximumThreads">The maximum number of threads for the queue to use.</param>
      <param name="processTimeout">The number of seconds before a process should timeout.</param>
      <param name="requeueOnTimeout">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue an item on timeout.</param>
      <param name="requeueOnException">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue after an exception.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Add(`0)">
      <summary>Adds an item to the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</summary>
      <param name="item">The item to add to the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds the elements of the specified collection to the end of the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            </summary>
      <param name="collection">
            The collection whose elements should be added to the end of the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            The collection itself cannot be null, but it can contain elements that are null, if type T is a reference type.
            </param>
      <exception cref="T:System.ArgumentNullException">collection is null.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
      <summary>
            Searches a range of elements in the sorted <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />, using a binary search algorithm, for an
            element using the specified comparer and returns the zero-based index of the element.
            </summary>
      <param name="index">The zero-based starting index of the range to search.</param>
      <param name="count">The length of the range to search.</param>
      <param name="item">The object to locate. The value can be null for reference types.</param>
      <param name="comparer">The Generic.IComparer implementation to use when comparing elements -or- null to use
            the default comparer: Generic.Comparer(Of T).Default</param>
      <returns>
            The zero-based index of item in the sorted <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />, if item is found; otherwise, a negative number that is the
            bitwise complement of the index of the next element that is larger than item or, if there is no larger element,
            the bitwise complement of count.
            </returns>
      <remarks>
        <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> must be sorted in order for this function to return an accurate result.
            </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">startIndex is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />
            -or- count is less than 0 -or- startIndex and count do not specify a valid section in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /></exception>
      <exception cref="T:System.InvalidOperationException">The default comparer, Generic.Comparer.Default, cannot find an
            implementation of the IComparable generic interface or the IComparable interface for type T.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.BinarySearch(`0)">
      <summary>
            Searches the entire sorted <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />, using a binary search algorithm, for an element using the
            default comparer and returns the zero-based index of the element.
            </summary>
      <param name="item">The object to locate. The value can be null for reference types.</param>
      <returns>
            The zero-based index of item in the sorted <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />, if item is found; otherwise, a negative number that is the
            bitwise complement of the index of the next element that is larger than item or, if there is no larger element,
            the bitwise complement of count.
            </returns>
      <remarks>
        <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> must be sorted in order for this function to return an accurate result.
            </remarks>
      <exception cref="T:System.InvalidOperationException">The default comparer, Generic.Comparer.Default, cannot find an
            implementation of the IComparable generic interface or the IComparable interface for type T.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
      <summary>
            Searches the entire sorted <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />, using a binary search algorithm, for an element using the
            specified comparer and returns the zero-based index of the element.
            </summary>
      <param name="item">The object to locate. The value can be null for reference types.</param>
      <param name="comparer">The Generic.IComparer implementation to use when comparing elements -or-
            null to use the default comparer: Generic.Comparer(Of T).Default</param>
      <returns>
            The zero-based index of item in the sorted <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />, if item is found; otherwise, a negative number that is the
            bitwise complement of the index of the next element that is larger than item or, if there is no larger element,
            the bitwise complement of count.
            </returns>
      <remarks>
        <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> must be sorted in order for this function to return an accurate result.
            </remarks>
      <exception cref="T:System.InvalidOperationException">The default comparer, Generic.Comparer.Default, cannot find an
            implementation of the IComparable generic interface or the IComparable interface for type T.</exception>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.CancellationToken">
      <summary>
            Gets the per processing thread cancellation token to check when a <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessTimeout" /> is specified.
            </summary>
      <remarks>
            This token should be checked in the user implemented <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunction" /> or <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction" /> to
            determine if a timeout has occurred so that the code can cleanly exit.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CanProcessItem(`0)">
      <summary>
            Determines if an item can be processed.
            </summary>
      <param name="item">The item T to process.</param>
      <returns>A <see cref="T:System.Boolean" /> value indicating whether it can process the item or not.</returns>
      <remarks>
        <para>
            Use this function instead of invoking the CanProcessItemFunction pointer
            directly, since implementation of this delegate is optional.
            </para>
      </remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.CanProcessItemFunction">
      <summary>
            Gets or sets the user function determining if an item is ready to be processed.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CanProcessItems(`0[])">
      <summary>
            Determines if all items can be processed.
            </summary>
      <param name="items">An array of items of type T.</param>
      <returns>A <see cref="T:System.Boolean" /> value indicating whether the process queue can process the items.</returns>
      <remarks>
        <para>
            Use this function instead of invoking the CanProcessItemFunction pointer
            directly, since implementation of this delegate is optional.
            </para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Clear">
      <summary>
            Removes all elements from the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Contains(`0)">
      <summary>
            Determines whether an element is in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            </summary>
      <param name="item">The object to locate in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />. The value can be null for reference types.</param>
      <returns>True, if item is found in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />; otherwise, false.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.ConvertAll``1(System.Converter{`0,``0})">
      <summary>Converts the elements in the current <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> to another type, and returns a <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> containing the
            converted elements.</summary>
      <param name="converter">A Converter delegate that converts each element from one type to another type.</param>
      <typeparam name="TOutput">The generic type used.</typeparam>
      <returns>A generic list of the target type containing the converted elements from the current <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</returns>
      <exception cref="T:System.ArgumentNullException">converter is null.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CopyTo(`0[],System.Int32)">
      <summary>Copies the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> to a compatible one-dimensional array, starting at the beginning of the
            target array.</summary>
      <param name="array">The one-dimensional array that is the destination of the elements copied from <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />. The
            array must have zero-based indexing.</param>
      <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
      <exception cref="T:System.ArgumentException">arrayIndex is equal to or greater than the length of array -or- the
            number of elements in the source <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> is greater than the available space from arrayIndex to the end of the
            destination array.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0.</exception>
      <exception cref="T:System.ArgumentNullException">array is null.</exception>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.Count">
      <summary>Gets the number of elements actually contained in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</summary>
      <returns>The number of elements actually contained in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature)">
      <summary>
            Creates a new asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> with the default settings: ProcessInterval = 100, MaximumThreads = 5,
            ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
      <param name="processItemFunction">Delegate that processes one item at a time.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature)">
      <summary>
            Creates a new asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> with the default settings: ProcessInterval = 100, MaximumThreads = 5,
            ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
      <param name="processItemFunction">Delegate that processes one item at a time.</param>
      <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Creates a new asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> using  specified settings.
            </summary>
      <param name="processItemFunction">Delegate that processes one item at a time.</param>
      <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
      <param name="processInterval">a <see cref="T:System.Double" /> value which represents the process interval in milliseconds.</param>
      <param name="maximumThreads">An <see cref="T:System.Int32" /> value that determines the maximum number of threads used to process items.</param>
      <param name="processTimeout">The number of seconds before a process should timeout.</param>
      <param name="requeueOnTimeout">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue an item on timeout.</param>
      <param name="requeueOnException">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue after an exception.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Int32)">
      <summary>
            Creates a new asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> with the default settings: ProcessInterval = 100,
            ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
      <param name="processItemFunction">Delegate that processes one item at a time.</param>
      <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
      <param name="maximumThreads">An <see cref="T:System.Int32" /> value that determines the maximum number of threads used to process items.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Creates a new asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> using specified settings.
            </summary>
      <param name="processItemFunction">Delegate that processes one item at a time.</param>
      <param name="processInterval">a <see cref="T:System.Double" /> value which represents the process interval in milliseconds.</param>
      <param name="maximumThreads">An <see cref="T:System.Int32" /> value that determines the maximum number of threads used to process items.</param>
      <param name="processTimeout">The number of seconds before a process should timeout.</param>
      <param name="requeueOnTimeout">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue an item on timeout.</param>
      <param name="requeueOnException">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue after an exception.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,System.Int32)">
      <summary>
            Creates a new asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> with the default settings: ProcessInterval = 100,
            ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
      <param name="processItemFunction">Delegate that processes one item at a time.</param>
      <param name="maximumThreads">An <see cref="T:System.Int32" /> value that determines the maximum number of threads used to process items.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature)">
      <summary>
            Creates a new asynchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> with the default settings: ProcessInterval = 100,
            MaximumThreads = 5, ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
      <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature)">
      <summary>
            Creates a new asynchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> with the default settings: ProcessInterval = 100,
            MaximumThreads = 5, ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
      <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
      <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Creates a new asynchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> using specified settings.
            </summary>
      <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
      <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
      <param name="processInterval">a <see cref="T:System.Double" /> value which represents the process interval in milliseconds.</param>
      <param name="maximumThreads">An <see cref="T:System.Int32" /> value that determines the maximum number of threads used to process items.</param>
      <param name="processTimeout">The number of seconds before a process should timeout.</param>
      <param name="requeueOnTimeout">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue an item on timeout.</param>
      <param name="requeueOnException">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue after an exception.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Int32)">
      <summary>
            Creates a new asynchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> with the default settings: ProcessInterval = 100,
            ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
      <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
      <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
      <param name="maximumThreads">An <see cref="T:System.Int32" /> value that determines the maximum number of threads used to process items.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Creates a new asynchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> using specified settings.
            </summary>
      <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
      <param name="processInterval">a <see cref="T:System.Double" /> value which represents the process interval in milliseconds.</param>
      <param name="maximumThreads">An <see cref="T:System.Int32" /> value that determines the maximum number of threads used to process items.</param>
      <param name="processTimeout">The number of seconds before a process should timeout.</param>
      <param name="requeueOnTimeout">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue an item on timeout.</param>
      <param name="requeueOnException">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue after an exception.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,System.Int32)">
      <summary>
            Creates a new asynchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> with the default settings: ProcessInterval = 100,
            ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
      <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
      <param name="maximumThreads">An <see cref="T:System.Int32" /> value that determines the maximum number of threads used to process items.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateRealTimeQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature)">
      <summary>
            Creates a new real-time <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> with the default settings: ProcessTimeout = Infinite,
            RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
      <param name="processItemFunction">Delegate that processes one item at a time.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateRealTimeQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature)">
      <summary>
            Creates a new real-time <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> with the default settings: ProcessTimeout = Infinite,
            RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
      <param name="processItemFunction">Delegate that processes one item at a time.</param>
      <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateRealTimeQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Creates a new real-time <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> using specified settings.
            </summary>
      <param name="processItemFunction">Delegate that processes one item at a time.</param>
      <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
      <param name="processTimeout">The number of seconds before a process should timeout.</param>
      <param name="requeueOnTimeout">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue an item on timeout.</param>
      <param name="requeueOnException">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue after an exception.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateRealTimeQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Creates a new real-time <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> using specified settings.
            </summary>
      <param name="processItemFunction">Delegate that processes one item at a time.</param>
      <param name="processTimeout">The number of seconds before a process should timeout.</param>
      <param name="requeueOnTimeout">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue an item on timeout.</param>
      <param name="requeueOnException">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue after an exception.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateRealTimeQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature)">
      <summary>
            Creates a new real-time, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> with the default settings: ProcessTimeout = Infinite,
            RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
      <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateRealTimeQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature)">
      <summary>
            Creates a new real-time, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> with the default settings: ProcessTimeout = Infinite,
            RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
      <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
      <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateRealTimeQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Creates a new real-time, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> using specified settings.
            </summary>
      <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
      <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
      <param name="processTimeout">The number of seconds before a process should timeout.</param>
      <param name="requeueOnTimeout">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue an item on timeout.</param>
      <param name="requeueOnException">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue after an exception.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateRealTimeQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Creates a new real-time, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> using specified settings.
            </summary>
      <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
      <param name="processTimeout">The number of seconds before a process should timeout.</param>
      <param name="requeueOnTimeout">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue an item on timeout.</param>
      <param name="requeueOnException">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue after an exception.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateSynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature)">
      <summary>
            Creates a new synchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> (i.e., single process thread) with the default settings:
            ProcessInterval = 100, ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
      <param name="processItemFunction">Delegate that processes one item at a time.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateSynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature)">
      <summary>
            Creates a new synchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> (i.e., single process thread) with the default settings:
            ProcessInterval = 100, ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
      <param name="processItemFunction">Delegate that processes one item at a time.</param>
      <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateSynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Double,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Creates a new synchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> (i.e., single process thread) using specified settings.
            </summary>
      <param name="processItemFunction">Delegate that processes one item at a time.</param>
      <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
      <param name="processInterval">a <see cref="T:System.Double" /> value which represents the process interval in milliseconds.</param>
      <param name="processTimeout">The number of seconds before a process should timeout.</param>
      <param name="requeueOnTimeout">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue an item on timeout.</param>
      <param name="requeueOnException">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue after an exception.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateSynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,System.Double,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Creates a new synchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> (i.e., single process thread) using specified settings.
            </summary>
      <param name="processItemFunction">Delegate that processes one item at a time.</param>
      <param name="processInterval">a <see cref="T:System.Double" /> value which represents the process interval in milliseconds.</param>
      <param name="processTimeout">The number of seconds before a process should timeout.</param>
      <param name="requeueOnTimeout">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue an item on timeout.</param>
      <param name="requeueOnException">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue after an exception.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateSynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature)">
      <summary>
            Creates a new synchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> (i.e., single process thread) with the default settings:
            ProcessInterval = 100, ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
      <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateSynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature)">
      <summary>
            Creates a new synchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> (i.e., single process thread) with the default settings:
            ProcessInterval = 100, ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
      <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
      <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateSynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Double,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Creates a new synchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> (i.e., single process thread) using specified settings.
            </summary>
      <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
      <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
      <param name="processInterval">a <see cref="T:System.Double" /> value which represents the process interval in milliseconds.</param>
      <param name="processTimeout">The number of seconds before a process should timeout.</param>
      <param name="requeueOnTimeout">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue an item on timeout.</param>
      <param name="requeueOnException">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue after an exception.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateSynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,System.Double,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Creates a new synchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> (i.e., single process thread) using specified settings.
            </summary>
      <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
      <param name="processInterval">a <see cref="T:System.Double" /> value which represents the process interval in milliseconds.</param>
      <param name="processTimeout">The number of seconds before a process should timeout.</param>
      <param name="requeueOnTimeout">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue an item on timeout.</param>
      <param name="requeueOnException">A <see cref="T:System.Boolean" /> value that indicates whether a process should requeue after an exception.</param>
      <returns>A ProcessQueue object based on type T.</returns>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.CurrentStatistics">
      <summary>
            Gets the current run-time statistics of the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> as a single group of values.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.DataAdded">
      <summary>
            Notifies queue that data was added and/or modified, so it can begin processing data.
            </summary>
      <remarks>
        <para>
            Derived classes *must* make sure to call this method after data gets added, so that the
            process timer can be enabled for intervaled <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> and data processing can begin.
            </para>
        <para>
            To make sure items in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> always get processed, this function is expected to be
            invoked from within a SyncLock of the exposed SyncRoot (i.e., InternalList).
            </para>
      </remarks>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueue`1.DefaultMaximumThreads">
      <summary>
            Default maximum number of processing threads.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueue`1.DefaultProcessInterval">
      <summary>
            Default processing interval (in milliseconds).
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueue`1.DefaultProcessTimeout">
      <summary>
            Default processing timeout (in milliseconds).
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueue`1.DefaultRequeueModeOnException">
      <summary>
            Default setting for requeuing mode on processing exceptions.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueue`1.DefaultRequeueModeOnTimeout">
      <summary>
            Default setting for requeuing mode on processing timeout.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueue`1.DefaultRequeueOnException">
      <summary>
            Default setting for requeuing items on processing exceptions.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueue`1.DefaultRequeueOnTimeout">
      <summary>
            Default setting for requeuing items on processing timeout.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Dispose">
      <summary>
            Releases all the resources used by the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> object.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Dispose(System.Boolean)">
      <summary>
            Releases the unmanaged resources used by the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> object and optionally releases the managed resources.
            </summary>
      <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
    </member>
    <member name="E:Gemstone.Threading.Collections.ProcessQueue`1.Disposed">
      <summary>
            Occurs when the class has been disposed.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.Enabled">
      <summary>
            Gets or sets indicator that the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> is currently enabled.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Exists(System.Predicate{`0})">
      <summary>Determines whether the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> contains elements that match the conditions defined by the specified
            predicate.</summary>
      <param name="match">The Predicate delegate that defines the conditions of the elements to search for.</param>
      <returns>True, if the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> contains one or more elements that match the conditions defined by the specified
            predicate; otherwise, false.</returns>
      <exception cref="T:System.ArgumentNullException">match is null.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Finalize">
      <summary>
            Releases the unmanaged resources before the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> object is reclaimed by <see cref="T:System.GC" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Find(System.Predicate{`0})">
      <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns
            the first occurrence within the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</summary>
      <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
      <returns>The first element that matches the conditions defined by the specified predicate, if found;
            otherwise, the default value for type T.</returns>
      <exception cref="T:System.ArgumentNullException">match is null.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.FindAll(System.Predicate{`0})">
      <summary>Retrieves all elements that match the conditions defined by the specified predicate.</summary>
      <param name="match">The Predicate delegate that defines the conditions of the elements to search for.</param>
      <returns>A generic list containing all elements that match the conditions defined by the specified predicate,
            if found; otherwise, an empty list.</returns>
      <exception cref="T:System.ArgumentNullException">match is null.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
      <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns
            the zero-based index of the first occurrence within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> that extends from the
            specified index to the last element.</summary>
      <param name="startIndex">The zero-based starting index of the search.</param>
      <param name="count">The number of elements in the section to search.</param>
      <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
      <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by
            match, if found; otherwise, –1.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">startIndex is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />
            -or- count is less than 0 -or- startIndex and count do not specify a valid section in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</exception>
      <exception cref="T:System.ArgumentNullException">match is null.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.FindIndex(System.Int32,System.Predicate{`0})">
      <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns
            the zero-based index of the first occurrence within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> that extends from the
            specified index to the last element.</summary>
      <param name="startIndex">The zero-based starting index of the search.</param>
      <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
      <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by
            match, if found; otherwise, –1.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">startIndex is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</exception>
      <exception cref="T:System.ArgumentNullException">match is null.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.FindIndex(System.Predicate{`0})">
      <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns
            the zero-based index of the first occurrence within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> that extends from the
            specified index to the last element.</summary>
      <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
      <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by
            match, if found; otherwise, –1.</returns>
      <exception cref="T:System.ArgumentNullException">match is null.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.FindLast(System.Predicate{`0})">
      <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</summary>
      <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
      <returns>The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type T.</returns>
      <exception cref="T:System.ArgumentNullException">match is null.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
      <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns
            the zero-based index of the last occurrence within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> that contains the
            specified number of elements and ends at the specified index.</summary>
      <param name="count">The number of elements in the section to search.</param>
      <param name="startIndex">The zero-based starting index of the backward search.</param>
      <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
      <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by
            match, if found; otherwise, –1.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">startIndex is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />
            -or- count is less than 0 -or- startIndex and count do not specify a valid section in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</exception>
      <exception cref="T:System.ArgumentNullException">match is null.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.FindLastIndex(System.Int32,System.Predicate{`0})">
      <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns
            the zero-based index of the last occurrence within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> that extends from the
            first element to the specified index.</summary>
      <param name="startIndex">The zero-based starting index of the backward search.</param>
      <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
      <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by
            match, if found; otherwise, –1.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">startIndex is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</exception>
      <exception cref="T:System.ArgumentNullException">match is null.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.FindLastIndex(System.Predicate{`0})">
      <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns
            the zero-based index of the last occurrence within the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</summary>
      <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
      <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by
            match, if found; otherwise, –1.</returns>
      <exception cref="T:System.ArgumentNullException">match is null.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Flush">
      <summary>
            Blocks the current thread, if the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> is active (i.e., user has called "Start" method), until all items
            in <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> are processed, and then stops the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            </summary>
      <remarks>
        <para>
            Begins processing items as quickly as possible, regardless of currently defined process interval, until all
            items in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> have been processed. Stops the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> when this function ends.
            This method is typically called on shutdown to make sure any remaining queued items get processed before the
            <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> is destructed.
            </para>
        <para>
            It is possible for items to be added to the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> while the flush is executing. The flush will continue to
            process items as quickly as possible until the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> is empty. Unless the user stops queuing items to be
            processed, the flush call may never return (not a happy situation on shutdown). For this reason, during this
            function call, requeuing of items on exception or process timeout is temporarily disabled.
            </para>
        <para>
            The <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> does not clear queue prior to destruction. If the user fails to call this method before the
            class is destructed, there may be items that remain unprocessed in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            </para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.ForEach(System.Action{`0})">
      <summary>Performs the specified action on each element of the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</summary>
      <param name="action">The Action delegate to perform on each element of the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</param>
      <exception cref="T:System.ArgumentNullException">action is null.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            </summary>
      <returns>An enumerator for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.GetRange(System.Int32,System.Int32)">
      <summary>Creates a shallow copy of a range of elements in the source <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</summary>
      <param name="count">The number of elements in the range.</param>
      <param name="index">The zero-based <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> index at which the range starts.</param>
      <returns>A shallow copy of a range of elements in the source <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">index is less than 0 -or- count is less than 0.</exception>
      <exception cref="T:System.ArgumentException">index and count do not denote a valid range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.IndexOf(`0)">
      <summary>Searches for the specified object and returns the zero-based index of the first occurrence within
            the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</summary>
      <param name="item">The object to locate in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />. The value can be null for reference types.</param>
      <returns>The zero-based index of the first occurrence of item within the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />, if found; otherwise, –1.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.IndexOf(`0,System.Int32)">
      <summary>Searches for the specified object and returns the zero-based index of the first occurrence within
            the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> that extends from the specified index to the last element.</summary>
      <param name="item">The object to locate in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />. The value can be null for reference types.</param>
      <param name="index">The zero-based starting index of the search.</param>
      <returns>The zero-based index of the first occurrence of item within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> that
            extends from index to the last element, if found; otherwise, –1.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">index is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.IndexOf(`0,System.Int32,System.Int32)">
      <summary>Searches for the specified object and returns the zero-based index of the first occurrence within
            the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> that starts at the specified index and contains the specified number of
            elements.</summary>
      <param name="count">The number of elements in the section to search.</param>
      <param name="item">The object to locate in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />. The value can be null for reference types.</param>
      <param name="index">The zero-based starting index of the search.</param>
      <returns>The zero-based index of the first occurrence of item within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> that
            starts at index and contains count number of elements, if found; otherwise, –1.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">index is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />
            -or- count is less than 0 -or- index and count do not specify a valid section in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Insert(System.Int32,`0)">
      <summary>Inserts an element into the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> at the specified index.</summary>
      <param name="item">The object to insert. The value can be null for reference types.</param>
      <param name="index">The zero-based index at which item should be inserted.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">index is less than 0 -or- index is greater than <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> length.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
      <summary>Inserts the elements of a collection into the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> at the specified index.</summary>
      <param name="collection">The collection whose elements should be inserted into the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />. The collection
            itself cannot be null, but it can contain elements that are null, if type T is a reference type.</param>
      <param name="index">The zero-based index at which the new elements should be inserted.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">index is less than 0 -or- index is greater than <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> length.</exception>
      <exception cref="T:System.ArgumentNullException">collection is null.</exception>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.InternalEnumerable">
      <summary>
            Allows derived classes to access the interfaced internal <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> directly.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.InternalList">
      <summary>
            Gets the internal list for direct use by <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.IsDisposed">
      <summary>
            Gets a flag that indicates whether the object has been disposed.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.IsEmpty">
      <summary>
            Gets a value that indicates whether the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> is empty.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.IsProcessing">
      <summary>
            Gets indicator that the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> is actively processing items.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.IsReadOnly">
      <summary>Gets a value indicating whether the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> is read-only.</summary>
      <returns>True, if the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> is read-only; otherwise, false. In the default implementation, this property
            always returns false.</returns>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.IsSynchronized">
      <summary>Gets a value indicating whether access to the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> is synchronized (thread safe).  Always returns true for <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</summary>
      <returns>true, <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> is always synchronized (thread safe).</returns>
      <remarks>The <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> is effectively "synchronized" since all functions SyncLock operations internally.</remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.Item(System.Int32)">
      <summary>
            Gets or sets the element at the specified index.
            </summary>
      <param name="index">The zero-based index of the element to get or set.</param>
      <returns>The element at the specified index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">index is less than 0 -or- index is equal to or greater than <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> length.</exception>
    </member>
    <member name="E:Gemstone.Threading.Collections.ProcessQueue`1.ItemProcessed">
      <summary>
            Event that is raised after an item has been successfully processed.
            </summary>
      <remarks>
        <para>Allows custom handling of successfully processed items.</para>
        <para>Allows notification when an item has completed processing in the allowed amount of time, if a process
            timeout is specified.</para>
        <para>Raised only when ProcessingStyle = OneAtATime (i.e., <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunction" /> is defined).</para>
      </remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ItemsBeingProcessed">
      <summary>
            Gets the total number of items currently being processed.
            </summary>
    </member>
    <member name="E:Gemstone.Threading.Collections.ProcessQueue`1.ItemsProcessed">
      <summary>
            Event that is raised after an array of items have been successfully processed.
            </summary>
      <remarks>
        <para>Allows custom handling of successfully processed items.</para>
        <para>Allows notification when an item has completed processing in the allowed amount of time, if a process
            timeout is specified.</para>
        <para>Raised only when when ProcessingStyle = ManyAtOnce (i.e., <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction" /> is defined).</para>
      </remarks>
    </member>
    <member name="E:Gemstone.Threading.Collections.ProcessQueue`1.ItemsTimedOut">
      <summary>
            Event that is raised if the processing time for an array of items exceeds the specified process timeout.
            </summary>
      <remarks>
        <para>Allows custom handling of items that took too long to process.</para>
        <para>Raised only when ProcessingStyle = ManyAtOnce (i.e., <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction" /> is defined).</para>
      </remarks>
    </member>
    <member name="E:Gemstone.Threading.Collections.ProcessQueue`1.ItemTimedOut">
      <summary>
            Event that is raised if an item's processing time exceeds the specified process timeout.
            </summary>
      <remarks>
        <para>Allows custom handling of items that took too long to process.</para>
        <para>Raised only when ProcessingStyle = OneAtATime (i.e., <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunction" /> is defined).</para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.LastIndexOf(`0)">
      <summary>Searches for the specified object and returns the zero-based index of the last occurrence within the
            entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</summary>
      <param name="item">The object to locate in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />. The value can be null for reference types.</param>
      <returns>The zero-based index of the last occurrence of item within the entire the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />, if found;
            otherwise, –1.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.LastIndexOf(`0,System.Int32)">
      <summary>Searches for the specified object and returns the zero-based index of the last occurrence within the
            range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> that extends from the first element to the specified index.</summary>
      <param name="item">The object to locate in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />. The value can be null for reference types.</param>
      <param name="index">The zero-based starting index of the backward search.</param>
      <returns>The zero-based index of the last occurrence of item within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> that
            extends from the first element to index, if found; otherwise, –1.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">index is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />. </exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.LastIndexOf(`0,System.Int32,System.Int32)">
      <summary>Searches for the specified object and returns the zero-based index of the last occurrence within the
            range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> that contains the specified number of elements and ends at the specified index.</summary>
      <param name="item">The object to locate in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />. The value can be null for reference types.</param>
      <param name="index">The zero-based starting index of the backward search.</param>
      <param name="count">The number of elements in the section to search.</param>
      <returns>The zero-based index of the last occurrence of item within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> that
            contains count number of elements and ends at index, if found; otherwise, –1.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">index is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> -or-
            count is less than 0 -or- index and count do not specify a valid section in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</exception>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.MaximumThreads">
      <summary>
            Gets or sets the maximum number of threads to process simultaneously.
            </summary>
      <returns>Maximum number of processing threads.</returns>
      <value>Sets the maximum number of processing threads.</value>
      <remarks>If MaximumThreads is set to one, item processing will be synchronous (i.e., ThreadingMode = Synchronous)</remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.Name">
      <summary>
            Gets or sets name for this <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            </summary>
      <remarks>
            This name is used for class identification in strings (e.g., used in error messages).
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.OnItemProcessed(`0)">
      <summary>
            Raises the base class <see cref="E:Gemstone.Threading.Collections.ProcessQueue`1.ItemProcessed" /> event.
            </summary>
      <param name="item">A generic type T to be passed to ItemProcessed.</param>
      <remarks>
            Derived classes cannot raise events of their base classes, so we expose event wrapper methods to accommodate
            as needed.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.OnItemsProcessed(`0[])">
      <summary>
            Raises the base class <see cref="E:Gemstone.Threading.Collections.ProcessQueue`1.ItemsProcessed" /> event.
            </summary>
      <param name="items">An array of generic type T to be passed to ItemsProcessed.</param>
      <remarks>
            Derived classes cannot raise events of their base classes, so we expose event wrapper methods to accommodate
            as needed.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.OnItemsTimedOut(`0[])">
      <summary>
            Raises the base class <see cref="E:Gemstone.Threading.Collections.ProcessQueue`1.ItemsTimedOut" /> event.
            </summary>
      <param name="items">An array of generic type T to be passed to ItemsProcessed.</param>
      <remarks>
            Derived classes cannot raise events of their base classes, so we expose event wrapper methods to accommodate
            as needed.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.OnItemTimedOut(`0)">
      <summary>
            Raises the base class <see cref="E:Gemstone.Threading.Collections.ProcessQueue`1.ItemTimedOut" /> event.
            </summary>
      <param name="item">A generic type T to be passed to ItemProcessed.</param>
      <remarks>
            Derived classes cannot raise events of their base classes, so we expose event wrapper methods to accommodate
            as needed.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.OnProcessException(System.Exception)">
      <summary>
            Raises the base class <see cref="E:Gemstone.Threading.Collections.ProcessQueue`1.ProcessException" /> event.
            </summary>
      <param name="ex">
        <see cref="T:System.Exception" /> to be passed to ProcessException.</param>
      <remarks>
            Derived classes cannot raise events of their base classes, so we expose event wrapper methods to accommodate
            as needed.
            </remarks>
    </member>
    <member name="E:Gemstone.Threading.Collections.ProcessQueue`1.ProcessException">
      <summary>
            Event that is raised if an exception is encountered while attempting to processing an item in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            </summary>
      <remarks>
            Processing will not stop for any exceptions thrown by the user function, but any captured exceptions will
            be exposed through this event.
            </remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessingIsRealTime">
      <summary>
            Gets indicator that items will be processed in real-time.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessingStyle">
      <summary>
            Gets the item <see cref="T:Gemstone.Threading.Collections.QueueProcessingStyle" /> for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> (i.e., one at a time or many at once).
            </summary>
      <returns>
        <para>OneAtATime, if the <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunction" /> is implemented.</para>
        <para>ManyAtOnce, if the <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction" /> is implemented.</para>
      </returns>
      <remarks>
        <para>The implemented item processing function determines the <see cref="T:Gemstone.Threading.Collections.QueueProcessingStyle" />.</para>
        <para>
            If the <see cref="T:Gemstone.Threading.Collections.QueueProcessingStyle" /> is ManyAtOnce, all available items in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> are presented for processing
            at each processing interval. If you expect items to be processed in the order in which they were received, make
            sure you use a synchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />. Real-time <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> are inherently synchronous.
            </para>
      </remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessInterval">
      <summary>
            Gets or sets the interval, in milliseconds, on which new items begin processing.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunction">
      <summary>
            Gets or sets the user function for processing individual items in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> one at a time.
            </summary>
      <remarks>
        <para>Cannot be defined simultaneously with <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction" />.</para>
        <para>A <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> must be defined to process a single item at a time or many items at once.</para>
        <para>Implementation makes ProcessingStyle = OneAtATime.</para>
      </remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction">
      <summary>
            Gets or sets the user function for processing multiple items in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> at once.
            </summary>
      <remarks>
        <para>This function and <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunction" /> cannot be defined at the same time</para>
        <para>A <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> must be defined to process a single item at a time or many items at once</para>
        <para>Implementation of this function makes ProcessingStyle = ManyAtOnce</para>
      </remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessTimeout">
      <summary>
            Gets or sets the maximum time, in milliseconds, allowed for processing an item.
            </summary>
      <returns>The maximum number of milliseconds allowed to process an item.</returns>
      <value>Sets the maximum number of milliseconds allowed to process an item.</value>
      <remarks>Set to Timeout.Infinite (i.e., -1) to allow processing to take as long as needed.</remarks>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueue`1.RealTimeProcessInterval">
      <summary>
            Default real-time processing interval (in milliseconds).
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Remove(`0)">
      <summary>Removes the first occurrence of a specific object from the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</summary>
      <param name="item">The object to remove from the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />. The value can be null for reference types.</param>
      <returns>True, if item is successfully removed; otherwise, false. This method also returns false if item was
            not found in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.RemoveAll(System.Predicate{`0})">
      <summary>Removes the all the elements that match the conditions defined by the specified predicate.</summary>
      <param name="match">The Predicate delegate that defines the conditions of the elements to remove.</param>
      <returns>The number of elements removed from the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</returns>
      <exception cref="T:System.ArgumentNullException">match is null.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.RemoveAt(System.Int32)">
      <summary>Removes the element at the specified index of the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</summary>
      <param name="index">The zero-based index of the element to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">index is less than 0 -or- index is equal to or greater than
            <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> length.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.RemoveRange(System.Int32,System.Int32)">
      <summary>Removes a range of elements from the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</summary>
      <param name="count">The number of elements to remove.</param>
      <param name="index">The zero-based starting index of the range of elements to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">index is less than 0 -or- count is less than 0.</exception>
      <exception cref="T:System.ArgumentException">index and count do not denote a valid range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.RequeueItem(`0,Gemstone.Threading.Collections.RequeueReason)">
      <summary>
            Requeues item into <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> according to specified requeue reason.
            </summary>
      <param name="item">A generic item of type T to be requeued.</param>
      <param name="reason">The reason the object is being requeued.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.RequeueItems(`0[],Gemstone.Threading.Collections.RequeueReason)">
      <summary>
            Requeues items into <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> according to specified requeue reason.
            </summary>
      <param name="items">Array of type T to be requeued.</param>
      <param name="reason">The reason the object is being requeued.</param>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.RequeueModeOnException">
      <summary>
            Gets or sets the mode of insertion used (prefix or suffix) when at item is placed back into the
            <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> after an exception occurs while processing.
            </summary>
      <remarks>Only relevant when RequeueOnException = True.</remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.RequeueModeOnTimeout">
      <summary>
            Gets or sets the mode of insertion used (prefix or suffix) when at item is placed back into the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />
            after processing times out.
            </summary>
      <remarks>Only relevant when RequeueOnTimeout = True.</remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.RequeueOnException">
      <summary>
            Gets or sets whether or not to automatically place an item back into the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> if an exception occurs
            while processing.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.RequeueOnTimeout">
      <summary>
            Gets or sets whether or not to automatically place an item back into the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> if the processing times out.
            </summary>
      <remarks>Ignored if the ProcessTimeout is set to Timeout.Infinite (i.e., -1).</remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Reverse">
      <summary>Reverses the order of the elements in the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Reverse(System.Int32,System.Int32)">
      <summary>Reverses the order of the elements in the specified range.</summary>
      <param name="count">The number of elements in the range to reverse.</param>
      <param name="index">The zero-based starting index of the range to reverse.</param>
      <exception cref="T:System.ArgumentException">index and count do not denote a valid range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />. </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">index is less than 0 -or- count is less than 0.</exception>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.RunTime">
      <summary>
            Gets the total amount of time, in seconds, that the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> has been active.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.SignalDataModified">
      <summary>
            Manually signals that data has been modified and processing should resume.
            </summary>
      <remarks>
            This function should be called in cases where a user may need to signal data modification. For example,
            if <typeparamref name="T" /> was a dictionary or list that was updated - you would need to manually
            signal that data had changed in this item.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Sort">
      <summary>Sorts the elements in the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />, using the default comparer.</summary>
      <exception cref="T:System.InvalidOperationException">The default comparer, Generic.Comparer.Default, cannot find an
            implementation of the IComparable generic interface or the IComparable interface for type T.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Sort(System.Collections.Generic.IComparer{`0})">
      <summary>Sorts the elements in the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />, using the specified comparer.</summary>
      <param name="comparer">The Generic.IComparer implementation to use when comparing elements, or null to use
            the default comparer: Generic.Comparer.Default.</param>
      <exception cref="T:System.ArgumentException">The implementation of comparer caused an error during the sort. For
            example, comparer might not return 0 when comparing an item with itself.</exception>
      <exception cref="T:System.InvalidOperationException">the comparer is null and the default comparer,
            Generic.Comparer.Default, cannot find an implementation of the IComparable generic interface or the
            IComparable interface for type T.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Sort(System.Comparison{`0})">
      <summary>Sorts the elements in the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />, using the specified comparison.</summary>
      <param name="comparison">The comparison to use when comparing elements.</param>
      <exception cref="T:System.ArgumentException">The implementation of comparison caused an error during the sort. For
            example, comparison might not return 0 when comparing an item with itself.</exception>
      <exception cref="T:System.ArgumentNullException">comparison is null.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
      <summary>Sorts the elements in a range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />, using the specified comparer.</summary>
      <param name="count">The length of the range to sort.</param>
      <param name="index">The zero-based starting index of the range to sort.</param>
      <param name="comparer">The Generic.IComparer implementation to use when comparing elements, or null to use
            the default comparer: Generic.Comparer.Default.</param>
      <exception cref="T:System.ArgumentException">The implementation of comparer caused an error during the sort. For
            example, comparer might not return 0 when comparing an item with itself.</exception>
      <exception cref="T:System.InvalidOperationException">the comparer is null and the default comparer,
            Generic.Comparer.Default, cannot find an implementation of the IComparable generic interface or the
            IComparable interface for type T.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">index is less than 0 -or- count is less than 0.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Start">
      <summary>
            Starts item processing.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.Status">
      <summary>
            Gets current status of <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Stop">
      <summary>
            Stops item processing.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.SynchronizedOperationType">
      <summary>
            Gets or sets the type of synchronized operation used to process items in a real-time <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />. 
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ThreadCount">
      <summary>
            Gets the current number of active threads.
            </summary>
      <returns>Current number of active threads.</returns>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ThreadingMode">
      <summary>
            Gets the current <see cref="T:Gemstone.Threading.Collections.QueueThreadingMode" /> for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> (i.e., synchronous or asynchronous).
            </summary>
      <remarks>
        <para>The maximum number of processing threads determines the <see cref="T:Gemstone.Threading.Collections.QueueThreadingMode" />.</para>
        <para>If the maximum threads are set to one, item processing will be synchronous
            (i.e., ThreadingMode = Synchronous).</para>
        <para>If the maximum threads are more than one, item processing will be asynchronous
            (i.e., ThreadingMode = Asynchronous).</para>
        <para>
            Note that for asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />, the processing interval will control how many threads are spawned
            at once. If items are processed faster than the specified processing interval, only one process thread
            will ever be spawned at a time. To ensure multiple threads are utilized to <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> items, lower
            the process interval (minimum process interval is 1 millisecond).
            </para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.ToArray">
      <summary>
            Copies the elements contained in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> to a new array. 
            </summary>
      <returns>A new array containing the elements copied from the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.</returns>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.TotalFunctionCalls">
      <summary>
            Gets the total number of calls to <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunction" /> or <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction" />.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.TotalProcessedItems">
      <summary>
            Gets the total number of items processed so far.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.TrueForAll(System.Predicate{`0})">
      <summary>Determines whether every element in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> matches the conditions defined by the specified
            predicate.</summary>
      <param name="match">The Predicate delegate that defines the conditions to check against the elements.</param>
      <returns>True, if every element in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> matches the conditions defined by the specified predicate;
            otherwise, false. If the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> has no elements, the return value is true.</returns>
      <exception cref="T:System.ArgumentNullException">match is null.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.TryTake(`0@)">
      <summary>
            Attempts to remove and return an object from the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            </summary>
      <param name="item">When this method returns, if the object was removed and returned successfully, item contains the removed object. If no object was available to be removed, the value is unspecified.</param>
      <returns>
        <c>true</c> if an object was removed and returned successfully; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.TryTake(`0[]@)">
      <summary>
            Attempts to remove and return all objects from the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            </summary>
      <param name="items">When this method returns, if any objects were removed and returned successfully, item array contains the removed objects. If no object was available to be removed, the value is null.</param>
      <returns>
        <c>true</c> if any objects were removed and returned successfully; otherwise, <c>false</c>.</returns>
    </member>
    <member name="T:Gemstone.Threading.Collections.ProcessQueue`1.CanProcessItemFunctionSignature">
      <summary>
            Function signature that determines if an item can be currently processed.
            </summary>
      <param name="item">Item to be checked for processing availability.</param>
      <returns>True, if item can be processed. The default is true.</returns>
      <remarks>
        <para>Implementation of this function is optional. It is assumed that an item can be processed if this
            function is not defined</para>
        <para>Items must eventually get to a state where they can be processed, or they will remain in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />
            indefinitely.</para>
        <para>
            Note that when this function is implemented and ProcessingStyle = ManyAtOnce (i.e., 
            <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction" /> is defined), then each item presented for 
            processing must evaluate as "CanProcessItem = True" before any items are processed.
            </para>
      </remarks>
    </member>
    <member name="T:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunctionSignature">
      <summary>
            Function signature that defines a method to process items one at a time.
            </summary>
      <param name="item">Item to be processed.</param>
      <remarks>
        <para>Required unless <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction" /> is implemented.</para>
        <para>Creates an asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> to process individual items - one item at a time - on multiple threads.</para>
      </remarks>
    </member>
    <member name="T:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunctionSignature">
      <summary>
            Function signature that defines a method to process multiple items at once.
            </summary>
      <param name="items">Items to be processed.</param>
      <remarks>
        <para>Required unless <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunction" /> is implemented.</para>
        <para>Creates an asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> to process groups of items simultaneously on multiple threads.</para>
      </remarks>
    </member>
    <member name="T:Gemstone.Threading.Collections.ProcessQueueStatistics">
      <summary>
            Represents the statistics of a <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.ActiveThreads">
      <summary>
            Gets the current number of active threads.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.IsEnabled">
      <summary>
            Gets indicator that the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> is currently enabled.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.IsProcessing">
      <summary>
            Gets indicator that the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> is actively processing items.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.ItemsBeingProcessed">
      <summary>
            Gets the total number of items currently being processed.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.ProcessingInterval">
      <summary>
            Gets the interval, in milliseconds, on which new items begin processing.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.ProcessingStyle">
      <summary>
            Gets the item <see cref="T:Gemstone.Threading.Collections.QueueProcessingStyle" /> for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> (i.e., one at a time or many at once).
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.ProcessTimeout">
      <summary>
            Gets the maximum time, in milliseconds, allowed for processing an item.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.QueueCount">
      <summary>
            Gets the number of elements queued for processing in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.RunTime">
      <summary>
            Gets the total amount of time, in seconds, that the process <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> has been active.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.ThreadingMode">
      <summary>
            Gets the current <see cref="T:Gemstone.Threading.Collections.QueueThreadingMode" /> for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> (i.e., synchronous or asynchronous).
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.TotalProcessedItems">
      <summary>
            Gets the total number of items processed so far.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.Collections.QueueProcessingStyle">
      <summary>
            Enumeration of possible <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> processing styles.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.QueueProcessingStyle.OneAtATime">
      <summary>
            Defines <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> processing delegate to process only one item at a time.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.QueueProcessingStyle.ManyAtOnce">
      <summary>
            Defines <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> processing delegate to process all currently available items in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            Items are passed into delegate as an array.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.Collections.QueueThreadingMode">
      <summary>
            Enumeration of possible <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> threading modes.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.QueueThreadingMode.Asynchronous">
      <summary>
            Processes several items in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> at once on different threads, where processing order is not important.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.QueueThreadingMode.Synchronous">
      <summary>
            Processes items in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" /> one at a time on a single thread, where processing order is important.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.Collections.RequeueMode">
      <summary>
            Enumeration of possible requeue modes.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.RequeueMode.Prefix">
      <summary>
            Requeues item at the beginning of the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.RequeueMode.Suffix">
      <summary>
            Requeues item at the end of the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1" />.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.Collections.RequeueReason">
      <summary>
            Enumeration of possible requeue reasons.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.RequeueReason.CannotProcess">
      <summary>
            Requeuing item since it cannot be processed at this time.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.RequeueReason.Exception">
      <summary>
            Requeuing item due to an exception.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.Collections.RequeueReason.Timeout">
      <summary>
            Requeuing item due to timeout.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.LogicalThreads.LogicalThread">
      <summary>
            Represents a thread of execution to which
            actions can be dispatched from other threads.
            </summary>
      <remarks>
        <para>
            This class provides a simple alternative to synchronization primitives
            such as wait handles and locks. Actions dispatched to a logical thread
            will be processed synchronously as though it was executed as consecutive
            method calls. All such actions can be dispatched from any thread in the
            system so method calls coming from multiple threads can be easily
            synchronized without locks, loops, wait handles, or timeouts.
            </para>
        <para>
            Note that the <see cref="T:Gemstone.Threading.LogicalThreads.LogicalThreadScheduler" /> implements its own
            thread pool to execute tasks pushed to logical threads. Executing
            long-running processes or using synchronization primitives with high
            contention or long timeouts can hinder the logical thread schedulers
            ability to schedule the actions of other logical threads. Like other
            thread pool implementations, you can mitigate this by increasing the
            maximum thread count of the logical thread scheduler, however it is
            recommended to avoid using synchronization primitives and instead
            synchronize those operations by running them as separate actions on
            the same logical thread.
            </para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThread.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.LogicalThreads.LogicalThread" /> class.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThread.Clear">
      <summary>
            Clears all actions from the logical thread.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.LogicalThreads.LogicalThread.CurrentThread">
      <summary>
            Gets the logical thread that is currently executing.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.LogicalThreads.LogicalThread.HasAction">
      <summary>
            Gets a flag that indicates whether the logical
            thread has any unprocessed actions left in its queue.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.LogicalThreads.LogicalThread.PriorityLevels">
      <summary>
            Gets the number of levels of priority
            supported by this logical thread.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThread.Push(System.Action)">
      <summary>
            Pushes an action to the logical thread.
            </summary>
      <param name="action">The action to be executed on this thread.</param>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThread.Push(System.Int32,System.Action)">
      <summary>
            Pushes an action to the logical thread.
            </summary>
      <param name="priority">The priority the action should be given when executing actions on the thread (higher numbers have higher priority).</param>
      <param name="action">The action to be executed on this thread.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="priority" /> is outside the range between 1 and <see cref="P:Gemstone.Threading.LogicalThreads.LogicalThread.PriorityLevels" />.</exception>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThread.SampleStatistics">
      <summary>
            Samples the statistics, providing current statistic
            values and resetting statistic counters.
            </summary>
      <returns>The current statistic values.</returns>
    </member>
    <member name="E:Gemstone.Threading.LogicalThreads.LogicalThread.UnhandledException">
      <summary>
            Handler for unhandled exceptions on the thread.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.LogicalThreads.LogicalThreadLocal`1">
      <summary>
            Represents a slot in the thread local memory space of each logical thread.
            </summary>
      <typeparam name="T">
        <markup>
          <include item="SMCMissingParamTag">
            <parameter>typeparam</parameter>
            <parameter>T</parameter>
            <parameter>T:Gemstone.Threading.LogicalThreads.LogicalThreadLocal`1</parameter>
          </include>
        </markup>
      </typeparam>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThreadLocal`1.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.LogicalThreads.LogicalThreadLocal`1" /> class.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThreadLocal`1.#ctor(System.Func{`0})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.LogicalThreads.LogicalThreadLocal`1" /> class.
            </summary>
      <param name="newObjectFactory">Factory to produce the initial value when accessing uninitialized values.</param>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThreadLocal`1.Dispose">
      <summary>
            Releases all the resources used by the <see cref="T:Gemstone.Threading.LogicalThreads.LogicalThreadLocal`1" /> object.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThreadLocal`1.Finalize">
      <summary>
            Releases the unmanaged resources before the <see cref="T:Gemstone.Threading.LogicalThreads.LogicalThreadLocal`1" /> object is reclaimed by <see cref="T:System.GC" />.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.LogicalThreads.LogicalThreadLocal`1.Value">
      <summary>
            Gets or sets the thread local object
            associated with the current logical thread.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.LogicalThreads.LogicalThreadOperation">
      <summary>
            Synchronized operation that executes on a logical thread.
            </summary>
      <remarks>
            This synchronized operation optionally supports a different usage pattern which will
            allow for asynchronous loops and signals to be passed between threads throughout an
            operation. The following is an example of how to implement a simple asynchronous loop
            between two threads using this class. Note that when used, the pattern requires more
            diligence on the user's part for handling exceptions and signaling when the operation
            is complete:
            
            <code>
            LogicalThread thread1 = new LogicalThread();
            LogicalThread thread2 = new LogicalThread();
            
            // Create logical thread operation with manually controlled call to RunIfPending
            LogicalThreadOperation operation = new LogicalThreadOperation(thread1, DoOperation, false);
            
            private void DoOperation()
            {
                ExecuteOnThread1();
                thread2.Push(() =&gt; operation.ExecuteAction(() =&gt;
                {
                    ExecuteOnThread2();
                    operation.RunIfPending();
                }));
            });
            </code></remarks>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.#ctor(Gemstone.Threading.LogicalThreads.LogicalThread,System.Action,System.Boolean)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.LogicalThreads.LogicalThreadOperation" /> class.
            </summary>
      <param name="thread">The thread on which to execute the operation's action.</param>
      <param name="action">The action to be executed.</param>
      <param name="autoRunIfPending">
            Set to <c>true</c> to execute <see cref="M:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.RunIfPending" /> automatically; otherwise,
            set to <c>false</c> for user controlled call timing.
            </param>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.#ctor(Gemstone.Threading.LogicalThreads.LogicalThread,System.Action,System.Int32,System.Boolean)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.LogicalThreads.LogicalThreadOperation" /> class.
            </summary>
      <param name="thread">The thread on which to execute the operation's action.</param>
      <param name="action">The action to be executed.</param>
      <param name="priority">The priority with which the action should be executed on the logical thread.</param>
      <param name="autoRunIfPending">
            Set to <c>true</c> to execute <see cref="M:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.RunIfPending" /> automatically; otherwise, 
            set to <c>false</c> for user controlled call timing.
            </param>
      <exception cref="T:System.ArgumentException">
        <paramref name="priority" /> is outside the range between 1 and <see cref="P:Gemstone.Threading.LogicalThreads.LogicalThread.PriorityLevels" />.</exception>
    </member>
    <member name="P:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.AutoRunIfPending">
      <summary>
            Gets flag that determines if <see cref="M:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.RunIfPending" /> will be called automatically.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.ExecuteAction(System.Action)">
      <summary>
            Executes an action once on the current thread.
            </summary>
      <param name="action">
        <see cref="T:System.Action" /> to run on current thread.</param>
      <remarks>
            This method provides exception handling for the action passed into this
            method with a couple of guarantees. The first is that regardless of what
            thread is executing the action passed into this method, the exception
            will be raised on the thread that the logical operation runs on. The
            second is that the RunIfPending method will be called if an exception
            does occur in the given action.
            </remarks>
    </member>
    <member name="P:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.IsPending">
      <summary>
            Gets a value to indicate whether the operation has an additional operation
            that is pending execution after the currently running operation has completed.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.IsRunning">
      <summary>
            Gets a value to indicate whether the operation is currently executing actions.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.Priority">
      <summary>
            Gets or sets default priority for logical thread operation.
            </summary>
      <remarks>
            Updates to default priority will only take effect during next <see cref="M:Gemstone.Threading.LogicalThreads.LogicalThread.Push(System.Int32,System.Action)" /> call.
            </remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> is outside the range between 1 and <see cref="P:Gemstone.Threading.LogicalThreads.LogicalThread.PriorityLevels" />.</exception>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.RequeueAction(System.Int32)">
      <summary>
            If the operation is running, the action has yet to be executed,
            and the given priority level differs from the queued action's
            priority level, this method will requeue the action at the given
            priority level.
            </summary>
      <param name="priority">The priority at which the current operation should be requeued.</param>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.RunIfPending">
      <summary>
            Starts the operation over at the beginning if the operation is pending or sets
            the operation state back to not running so it can run again.
            </summary>
      <remarks>
            This method must be called at the end of an operation in order to set the state
            of the operation back to running or not running so that the operation can run again.
            The existence of this method makes this implementation different from other synchronized
            operations in that it requires more diligence on the user's part to signal when the
            operation is complete. In turn, this allows the user to implement complex operations
            that may involve asynchronous loops and signaling patterns that would not be possible
            with the <see cref="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" /> interface.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.RunOnce">
      <summary>
            Executes the action on the current thread or marks the operation as
            pending if the operation is already running.
            </summary>
      <remarks>
            When the operation is marked as pending, it will run again at the next
            call to <see cref="M:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.RunIfPending" />. This can be useful if an update to
            an object's state has invalidated the operation that is currently running
            and will therefore need to be run again.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.RunOnceAsync">
      <summary>
            Executes the action on another thread or marks the operation as pending
            if the operation is already running.
            </summary>
      <remarks>
            When the operation is marked as pending, it will run again at the next
            call to <see cref="M:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.RunIfPending" />. This can be useful if an update to
            an object's state has invalidated the operation that is currently running
            and will therefore need to be run again.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.TryRunOnce">
      <summary>
            Attempts to execute the action on the current thread.
            Does nothing if the operation is already running.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThreadOperation.TryRunOnceAsync">
      <summary>
            Attempts to execute the action on another thread.
            Does nothing if the operation is already running.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.LogicalThreads.LogicalThreadScheduler">
      <summary>
            Manages synchronization of actions by dispatching actions
            to logical threads to be processed synchronously.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThreadScheduler.#ctor(System.Int32)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.LogicalThreads.LogicalThreadScheduler" /> class.
            </summary>
      <param name="priorityLevels">The number of levels of priority supported by this logical thread scheduler.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="priorityLevels" /> is less than or equal to zero.</exception>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThreadScheduler.CreateThread">
      <summary>
            Creates a new logical thread whose
            execution is managed by this scheduler.
            </summary>
      <returns>A new logical thread managed by this scheduler.</returns>
    </member>
    <member name="P:Gemstone.Threading.LogicalThreads.LogicalThreadScheduler.MaxThreadCount">
      <summary>
            Gets or sets the target for the maximum number of physical
            threads managed by this synchronization manager at any given time.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.LogicalThreads.LogicalThreadScheduler.PriorityLevels">
      <summary>
            Gets the number of levels of priority
            supported by this scheduler.
            </summary>
    </member>
    <member name="E:Gemstone.Threading.LogicalThreads.LogicalThreadScheduler.UnhandledException">
      <summary>
            Triggered when an action managed by this
            synchronization manager throws an exception.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.LogicalThreads.LogicalThreadScheduler.UseBackgroundThreads">
      <summary>
            Gets or sets the flag that determines whether the threads in
            the schedulers thread pool should be background threads.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.LogicalThreads.LogicalThreadStatistics">
      <summary>
            Represents a set of statistics gathered about
            the execution time of actions on a logical thread.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.LogicalThreads.LogicalThreadStatistics.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Gemstone.Threading.LogicalThreads.LogicalThreadStatistics</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Gemstone.Threading.LogicalThreads.LogicalThreadStatistics.ExecutionCount">
      <summary>
            Gets the total number of actions executed on the logical thread.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.LogicalThreads.LogicalThreadStatistics.MaxExecutionTime">
      <summary>
            Gets the execution time of the longest running action.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.LogicalThreads.LogicalThreadStatistics.MinExecutionTime">
      <summary>
            Gets the execution time of the shortest running action.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.LogicalThreads.LogicalThreadStatistics.TotalExecutionTime">
      <summary>
            Gets the total execution time of all actions executed on the logical thread.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.Strands.PriorityStrand">
      <summary>
            Schedules tasks in a collection of FIFO queues and executes them in priority order.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Strands.PriorityStrand.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.PriorityStrand" /> class with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.PriorityStrand" /> class.
            </summary>
      <param name="synchronizedOperationFactory">Factory function for creating the synchronized operation to be used for processing tasks.</param>
    </member>
    <member name="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory,System.Int32)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.PriorityStrand" /> class.
            </summary>
      <param name="synchronizedOperationFactory">Factory function for creating the synchronized operation to be used for processing tasks.</param>
      <param name="priorityLevels">The number of priority levels to be pre-allocated by the priority queue.</param>
    </member>
    <member name="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(System.Int32)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.PriorityStrand" /> class with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />.
            </summary>
      <param name="priorityLevels">The number of priority levels to be pre-allocated by the priority queue.</param>
    </member>
    <member name="M:Gemstone.Threading.Strands.PriorityStrand.GetScheduler(System.Int32)">
      <summary>
            Gets a <see cref="T:System.Threading.Tasks.TaskScheduler" /> used to queue tasks at a specific priority.
            </summary>
      <param name="priority">The priority at which tasks should be queued by the returned <see cref="T:System.Threading.Tasks.TaskScheduler" />. Higher numbers are higher in priority!</param>
      <returns>A <see cref="T:System.Threading.Tasks.TaskScheduler" /> that queues tasks into the strand at the given priority.</returns>
      <remarks>For a strand with <c>n</c> priorities, it is recommended to use priority levels between <c>0</c> and <c>n-1</c> inclusive.</remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="priority" /> is less than zero</exception>
    </member>
    <member name="T:Gemstone.Threading.Strands.Strand">
      <summary>
            Schedules tasks in a FIFO queue and executes them in a synchronized asynchronous loop.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.Strand" /> class with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.Strand" /> class.
            </summary>
      <param name="synchronizedOperationFactory">Factory function for creating the synchronized operation to be used for processing tasks.</param>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.GetScheduledTasks">
      <summary>
            For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task" />
            instances currently queued to the scheduler waiting to be executed.
            </summary>
      <returns>An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</returns>
    </member>
    <member name="P:Gemstone.Threading.Strands.Strand.MaximumConcurrencyLevel">
      <summary>
            Indicates the maximum concurrency level this <see cref="T:System.Threading.Tasks.TaskScheduler" /> is able to support.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.QueueTask(System.Threading.Tasks.Task)">
      <summary>
            Queues a <see cref="T:System.Threading.Tasks.Task" /> to the scheduler.
            </summary>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task" /> to be queued.</param>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.TryDequeue(System.Threading.Tasks.Task)">
      <summary>
            Attempts to dequeue a <see cref="T:System.Threading.Tasks.Task" /> that was previously queued to this scheduler.
            </summary>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task" /> to be dequeued.</param>
      <returns>A Boolean denoting whether the task argument was successfully dequeued.</returns>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
      <summary>
            Attempts to execute a task inline, but only if this method is
            called on the processing thread to avoid parallel execution of tasks.
            </summary>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task" /> to be executed.</param>
      <param name="taskWasPreviouslyQueued">
            A Boolean denoting whether or not task has previously been queued.
            If this parameter is True, then the task may have been previously queued (scheduled);
            if False, then the task is known not to have been queued,
            and this call is being made in order to execute the task inline without queuing it.
            </param>
      <returns>A Boolean value indicating whether the task was executed inline.</returns>
      <remarks>
            Inline execution allows tasks to skip the line and run out of order.
            The only reason inline execution is supported at all is to avoid a common
            case of deadlocking where a task is queued in advance of another task that it
            depends on (via <see cref="M:System.Threading.Tasks.Task.Wait" />, for instance). However, deadlocks can
            still occur when waiting on tasks scheduled by a different strand. To avoid
            out-of-order execution and deadlocks, be very careful about using API calls
            that wait on tasks.
            </remarks>
    </member>
    <member name="T:Gemstone.Threading.WaitHandleExtensions.WaitHandleExtensions">
      <summary>
            Defines extension functions related to manipulation wait handle objects.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.WaitHandleExtensions.WaitHandleExtensions.WaitAll(System.Collections.Generic.IEnumerable{System.Threading.ManualResetEventSlim},Gemstone.Threading.Cancellation.CancellationToken)">
      <summary>
            Waits for all the specified <see cref="T:System.Threading.ManualResetEventSlim" /> elements to receive a signal.
            </summary>
      <param name="resetEvents">Collection of <see cref="T:System.Threading.ManualResetEventSlim" /> elements to operate on.</param>
      <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> to observe, if any.</param>
      <returns>
        <c>true</c> when every <see cref="T:System.Threading.ManualResetEventSlim" /> element has received a signal; otherwise the method never returns unless cancelled.</returns>
      <remarks>
            Using <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" /> will cause all <see cref="T:System.Threading.ManualResetEventSlim" /> elements
            to be upgraded to a standard <see cref="T:System.Threading.ManualResetEvent" />, these overloads allow similar functionality without
            incurring unconditional inflation of the underlying <see cref="T:System.Threading.ManualResetEvent" />.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="resetEvents" /> is <c>null</c>.</exception>
    </member>
    <member name="M:Gemstone.Threading.WaitHandleExtensions.WaitHandleExtensions.WaitAll(System.Collections.Generic.IEnumerable{System.Threading.ManualResetEventSlim},System.Int32,Gemstone.Threading.Cancellation.CancellationToken)">
      <summary>
            Waits for all the specified <see cref="T:System.Threading.ManualResetEventSlim" /> elements to receive a signal, using an integer value to specify the maximum time interval,in milliseconds, to wait.
            </summary>
      <param name="resetEvents">Collection of <see cref="T:System.Threading.ManualResetEventSlim" /> elements to operate on.</param>
      <param name="timeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
      <param name="cancellationToken">A <see cref="T:Gemstone.Threading.Cancellation.CancellationToken" /> to observe, if any.</param>
      <returns>
        <c>true</c> when every <see cref="T:System.Threading.ManualResetEventSlim" /> element has received a signal; otherwise <c>false</c>.</returns>
      <remarks>
            Using <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" /> will cause all <see cref="T:System.Threading.ManualResetEventSlim" /> elements
            to be upgraded to a standard <see cref="T:System.Threading.ManualResetEvent" />, these overloads allow similar functionality without
            incurring unconditional inflation of the underlying <see cref="T:System.Threading.ManualResetEvent" />.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="resetEvents" /> is <c>null</c>.</exception>
    </member>
    <member name="M:Gemstone.Threading.WaitHandleExtensions.WaitHandleExtensions.WaitAll(System.Collections.Generic.IEnumerable{System.Threading.ManualResetEventSlim},System.Int32,System.Threading.CancellationToken)">
      <summary>
            Waits for all the specified <see cref="T:System.Threading.ManualResetEventSlim" /> elements to receive a signal, using an integer value to specify the maximum time interval,in milliseconds, to wait.
            </summary>
      <param name="resetEvents">Collection of <see cref="T:System.Threading.ManualResetEventSlim" /> elements to operate on.</param>
      <param name="timeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
      <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> to observe.</param>
      <returns>
        <c>true</c> when every <see cref="T:System.Threading.ManualResetEventSlim" /> element has received a signal; otherwise <c>false</c>.</returns>
      <remarks>
            Using <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" /> will cause all <see cref="T:System.Threading.ManualResetEventSlim" /> elements
            to be upgraded to a standard <see cref="T:System.Threading.ManualResetEvent" />, these overloads allow similar functionality without
            incurring unconditional inflation of the underlying <see cref="T:System.Threading.ManualResetEvent" />.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="resetEvents" /> is <c>null</c>.</exception>
    </member>
    <member name="M:Gemstone.Threading.WaitHandleExtensions.WaitHandleExtensions.WaitAll(System.Collections.Generic.IEnumerable{System.Threading.ManualResetEventSlim},System.Threading.CancellationToken)">
      <summary>
            Waits for all the specified <see cref="T:System.Threading.ManualResetEventSlim" /> elements to receive a signal.
            </summary>
      <param name="resetEvents">Collection of <see cref="T:System.Threading.ManualResetEventSlim" /> elements to operate on.</param>
      <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> to observe.</param>
      <returns>
        <c>true</c> when every <see cref="T:System.Threading.ManualResetEventSlim" /> element has received a signal; otherwise the method never returns unless cancelled.</returns>
      <remarks>
            Using <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" /> will cause all <see cref="T:System.Threading.ManualResetEventSlim" /> elements
            to be upgraded to a standard <see cref="T:System.Threading.ManualResetEvent" />, these overloads allow similar functionality without
            incurring unconditional inflation of the underlying <see cref="T:System.Threading.ManualResetEvent" />.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="resetEvents" /> is <c>null</c>.</exception>
    </member>
    <member name="M:Gemstone.Threading.WaitHandleExtensions.WaitHandleExtensions.WaitAll(System.Collections.Generic.IEnumerable{System.Threading.ManualResetEventSlim},System.TimeSpan,Gemstone.Threading.Cancellation.CancellationToken)">
      <summary>
            Waits for all the specified <see cref="T:System.Threading.ManualResetEventSlim" /> elements to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the maximum time interval to wait.
            </summary>
      <param name="resetEvents">Collection of <see cref="T:System.Threading.ManualResetEventSlim" /> elements to operate on.</param>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</param>
      <param name="cancellationToken">A <see cref="T:Gemstone.Threading.Cancellation.CancellationToken" /> to observe, if any.</param>
      <returns>
        <c>true</c> when every <see cref="T:System.Threading.ManualResetEventSlim" /> element has received a signal; otherwise <c>false</c>.</returns>
      <remarks>
            Using <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" /> will cause all <see cref="T:System.Threading.ManualResetEventSlim" /> elements
            to be upgraded to a standard <see cref="T:System.Threading.ManualResetEvent" />, these overloads allow similar functionality without
            incurring unconditional inflation of the underlying <see cref="T:System.Threading.ManualResetEvent" />.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="resetEvents" /> is <c>null</c>.</exception>
    </member>
    <member name="M:Gemstone.Threading.WaitHandleExtensions.WaitHandleExtensions.WaitAll(System.Collections.Generic.IEnumerable{System.Threading.ManualResetEventSlim},System.TimeSpan,System.Threading.CancellationToken)">
      <summary>
            Waits for all the specified <see cref="T:System.Threading.ManualResetEventSlim" /> elements to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the maximum time interval to wait.
            </summary>
      <param name="resetEvents">Collection of <see cref="T:System.Threading.ManualResetEventSlim" /> elements to operate on.</param>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</param>
      <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> to observe.</param>
      <returns>
        <c>true</c> when every <see cref="T:System.Threading.ManualResetEventSlim" /> element has received a signal; otherwise <c>false</c>.</returns>
      <remarks>
            Using <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" /> will cause all <see cref="T:System.Threading.ManualResetEventSlim" /> elements
            to be upgraded to a standard <see cref="T:System.Threading.ManualResetEvent" />, these overloads allow similar functionality without
            incurring unconditional inflation of the underlying <see cref="T:System.Threading.ManualResetEvent" />.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="resetEvents" /> is <c>null</c>.</exception>
    </member>
  </members>
</doc>